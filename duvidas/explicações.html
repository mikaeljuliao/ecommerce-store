<!--
================================================================================
DÃšVIDA: Por que nÃ£o usei o StrictMode no inÃ­cio do projeto?
================================================================================

No inÃ­cio do projeto, optei por NÃƒO usar o StrictMode do React, mesmo ele sendo
o padrÃ£o do template do Vite + React + TypeScript.

O StrictMode existe apenas em ambiente de desenvolvimento e serve para ajudar
a identificar problemas como:
- efeitos colaterais
- uso de APIs legadas
- padrÃµes inseguros de cÃ³digo

PorÃ©m, no React 18, o StrictMode funciona de uma forma especÃ­fica:
ele executa propositalmente algumas partes do cÃ³digo DUAS VEZES em desenvolvimento.

Isso inclui:
- useEffect
- inicializaÃ§Ãµes de estado
- algumas lÃ³gicas internas
- possÃ­veis chamadas de API

Isso NÃƒO Ã© bug, Ã© comportamento intencional do React.

O problema Ã© que, no inÃ­cio do projeto, isso atrapalha o aprendizado e o debug,
principalmente quando estamos lidando com:
- reducers
- regras de negÃ³cio (carrinho)
- chamadas de API
- localStorage

Exemplos de confusÃ£o que podem acontecer:
- A API parece estar sendo chamada duas vezes
- Um item pode parecer duplicado no carrinho
- Um efeito parece "quebrado", quando na verdade Ã© o StrictMode

Como o foco inicial do projeto Ã©:
- entender a lÃ³gica
- modelar bem os tipos com TypeScript
- construir a arquitetura corretamente

o StrictMode foi desativado temporariamente.

Importante: isso NÃƒO significa que o StrictMode Ã© ruim ou nÃ£o serÃ¡ usado.
Ele pode (e deve) ser reativado depois, quando a lÃ³gica estiver sÃ³lida
e o comportamento da aplicaÃ§Ã£o estiver bem entendido.

================================================================================
RESUMO:
- StrictMode roda cÃ³digo duas vezes em dev
- Isso pode gerar confusÃ£o no inÃ­cio
- Foi desativado conscientemente
- Pode ser reativado mais tarde
================================================================================
-->



<!--
================================================================================
DÃšVIDA: Por que validar o container antes de usar createRoot?
================================================================================

Ao montar a aplicaÃ§Ã£o React, usamos esse cÃ³digo:

const container = document.getElementById('root')

O mÃ©todo getElementById pode retornar dois valores:
- um elemento HTML (HTMLElement)
- ou null, caso o elemento nÃ£o exista

Ou seja, para o TypeScript, o tipo de container Ã©:
HTMLElement | null

O problema Ã© que o React NÃƒO aceita null no createRoot.
Ele exige um elemento HTML vÃ¡lido.

Se passarmos null, a aplicaÃ§Ã£o pode:
- quebrar
- nÃ£o renderizar nada
- gerar erro difÃ­cil de entender

Por isso, fazemos a verificaÃ§Ã£o:

if (!container) {
  throw new Error('Root container missing')
}

Essa verificaÃ§Ã£o serve para:
- garantir que o elemento realmente existe
- interromper a aplicaÃ§Ã£o imediatamente se algo estiver errado
- mostrar um erro claro no console

Isso Ã© muito melhor do que deixar a aplicaÃ§Ã£o falhar silenciosamente.

================================================================================
IMPORTANTE PARA O TYPESCRIPT
================================================================================

Depois desse if, o TypeScript entende automaticamente que:
- se o cÃ³digo chegou aqui
- entÃ£o container NÃƒO Ã© null

Isso se chama "type narrowing" (estreitamento de tipo).

Antes do if:
HTMLElement | null

Depois do if:
HTMLElement

Isso elimina a necessidade de usar o operador ! (non-null assertion).

================================================================================
COMPARAÃ‡ÃƒO COM O OPERADOR !
================================================================================

Forma mais comum (menos segura):

createRoot(document.getElementById('root')!).render(...)

O ! basicamente diz:
"confia em mim, isso nunca serÃ¡ null"

O problema:
- se for null, o erro acontece do mesmo jeito
- o TypeScript deixa de proteger
- o cÃ³digo fica menos seguro

Forma usada no projeto (mais profissional):

const container = document.getElementById('root')

if (!container) {
  throw new Error('Root container missing')
}

createRoot(container).render(...)

Essa abordagem:
- Ã© mais explÃ­cita
- Ã© mais segura
- mostra maturidade tÃ©cnica
- facilita debug
- mantÃ©m o TypeScript trabalhando a favor

================================================================================
ANALOGIA SIMPLES
================================================================================

Ã‰ como tentar usar dinheiro sem saber se ele existe:

Errado:
comprarAlgo(dinheiro!)

Correto:
if (!dinheiro) {
  throw new Error('Sem saldo')
}

comprarAlgo(dinheiro)

================================================================================
RESUMO FINAL
================================================================================

- getElementById pode retornar null
- React nÃ£o aceita null no createRoot
- O if garante seguranÃ§a
- O erro fica explÃ­cito
- Evita uso desnecessÃ¡rio do !
- CÃ³digo mais profissional e confiÃ¡vel
================================================================================
-->









<!--
================================================================================
TAILWIND CSS â€” PROCESSO COMPLETO DE INSTALAÃ‡ÃƒO (VERSÃƒO 3)
================================================================================

Este projeto utiliza Tailwind CSS na versÃ£o 3 de forma consciente e intencional.

A versÃ£o mais recente (v4) apresentou dificuldades de setup no ambiente com Vite,
principalmente relacionadas Ã  geraÃ§Ã£o automÃ¡tica de arquivos de configuraÃ§Ã£o
e integraÃ§Ã£o com o bundler.

Como o foco do projeto Ã© aprendizado, clareza e estabilidade,
a versÃ£o 3 foi escolhida por ser:
- amplamente utilizada no mercado
- bem documentada
- estÃ¡vel
- previsÃ­vel

================================================================================
PASSO 1 â€” REMOÃ‡ÃƒO DO TAILWIND (CASO JÃ EXISTA)
================================================================================

Antes de instalar o Tailwind v3, Ã© importante remover qualquer resÃ­duo
de instalaÃ§Ãµes anteriores para evitar conflitos de versÃ£o.

Comandos utilizados:

npm uninstall tailwindcss postcss autoprefixer

ApÃ³s isso, verificar e remover manualmente, se existirem:
- tailwind.config.js
- postcss.config.js

Isso garante um ambiente limpo para a nova instalaÃ§Ã£o.

================================================================================
PASSO 2 â€” INSTALAÃ‡ÃƒO DO TAILWIND CSS v3
================================================================================

InstalaÃ§Ã£o explÃ­cita da versÃ£o 3:

npm install -D tailwindcss@3 postcss autoprefixer

ApÃ³s a instalaÃ§Ã£o, gerar os arquivos de configuraÃ§Ã£o:

npx tailwindcss init -p

Esse comando cria automaticamente:
- tailwind.config.js
- postcss.config.js

================================================================================
PASSO 3 â€” CONFIGURAÃ‡ÃƒO DO tailwind.config.js
================================================================================

Na versÃ£o 3 do Tailwind, o arquivo de configuraÃ§Ã£o utiliza CommonJS.
Por isso, Ã© obrigatÃ³rio usar module.exports.

ConteÃºdo final do arquivo:

module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

O campo "content" informa ao Tailwind onde procurar as classes
para gerar os estilos corretamente.

================================================================================
PASSO 4 â€” CONFIGURAÃ‡ÃƒO DO CSS GLOBAL
================================================================================

No arquivo src/index.css, foram adicionadas as diretivas do Tailwind:

@tailwind base;
@tailwind components;
@tailwind utilities;

Esse arquivo Ã© importado no main.tsx, garantindo que os estilos
sejam aplicados globalmente na aplicaÃ§Ã£o.

================================================================================
PASSO 5 â€” TESTE DE FUNCIONAMENTO
================================================================================

Para confirmar que o Tailwind estÃ¡ funcionando corretamente,
foi aplicado um layout simples no componente principal da aplicaÃ§Ã£o.

Exemplo utilizado no App.tsx:

function App() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-900 text-white">
      <h1 className="text-3xl font-bold">
        Tailwind v3 funcionando
      </h1>
    </div>
  )
}

export default App

Se o fundo aparecer escuro, o texto branco e centralizado,
significa que o Tailwind estÃ¡ configurado corretamente.

================================================================================
CONCLUSÃƒO
================================================================================

A escolha pelo Tailwind CSS v3 nÃ£o representa atraso tecnolÃ³gico,
mas sim uma decisÃ£o tÃ©cnica consciente para manter o foco no aprendizado,
evitar problemas de setup e garantir produtividade.

VersÃµes mais novas podem ser avaliadas futuramente,
quando a base do projeto estiver sÃ³lida.

================================================================================
-->






















<!--
===========================================
ANOTAÃ‡ÃƒO IMPORTANTE â€” TYPESCRIPT + RUNTIME
===========================================

Essa foi, de longe, a parte MAIS CONFUSA do inÃ­cio do projeto.
Quase desisti aqui, entÃ£o estou documentando com bastante detalhe
pra nunca mais passar por isso.

-------------------------------------------
1ï¸âƒ£ O QUE SIGNIFICA "EXISTIR EM RUNTIME"?
-------------------------------------------

"Runtime" Ã© o MOMENTO em que o JavaScript estÃ¡ rodando de verdade,
ou seja:

- Quando o navegador abre a aplicaÃ§Ã£o
- Quando o cÃ³digo jÃ¡ virou JavaScript
- Quando NÃƒO EXISTE mais TypeScript

ðŸ‘‰ Runtime = cÃ³digo final executando no navegador.

-------------------------------------------
2ï¸âƒ£ TYPESCRIPT NÃƒO EXISTE EM RUNTIME
-------------------------------------------

TypeScript Ã© sÃ³ uma CAMADA DE DESENVOLVIMENTO.

Antes de rodar no navegador:
- O TypeScript Ã© COMPILADO
- Interfaces e types SÃƒO APAGADOS
- SÃ³ sobra JavaScript

Exemplo:

interface Product {
  id: number
  title: string
}

â¬‡ï¸ Depois da compilaÃ§Ã£o â¬‡ï¸

(NADA)

Isso simplesmente NÃƒO EXISTE mais.

Ou seja:
âŒ Interface NÃƒO vira variÃ¡vel
âŒ Interface NÃƒO vira objeto
âŒ Interface NÃƒO existe no JavaScript final

Ela sÃ³ serve para:
- ajudar o editor
- evitar erros
- dar seguranÃ§a de tipo

-------------------------------------------
3ï¸âƒ£ O ERRO QUE ACONTECEU NO PROJETO
-------------------------------------------

Eu estava importando a interface assim:

import { Product } from '../types/Product'

Isso faz o bundler (Vite) pensar:

"Ok, entÃ£o em runtime vai existir algo chamado Product"

MAS NÃƒO EXISTE.

Resultado:
- O Vite tenta encontrar Product no JavaScript
- NÃ£o acha nada
- A aplicaÃ§Ã£o quebra

-------------------------------------------
4ï¸âƒ£ POR QUE ISSO ACONTECE EM PROJETOS MODERNOS?
-------------------------------------------

Meu projeto usa configuraÃ§Ãµes modernas, como:

- Vite
- TypeScript strict
- moduleResolution: "bundler"
- verbatimModuleSyntax: true

Essas configs sÃ£o MAIS RÃGIDAS de propÃ³sito.

Elas obrigam o dev a deixar claro:
- o que Ã© TYPE (sÃ³ TS)
- o que Ã© VALUE (existe em runtime)

-------------------------------------------
5ï¸âƒ£ A SOLUÃ‡ÃƒO CORRETA (IMPORTANTE)
-------------------------------------------

Sempre que importar APENAS tipos ou interfaces,
PRECISO usar:

import type { Product } from '../types/Product'

Isso diz claramente:

"Isso aqui Ã© SÃ“ PARA O TYPESCRIPT.
NÃƒO tente usar isso no JavaScript final."

Assim:
âœ… O TypeScript entende
âœ… O Vite nÃ£o tenta resolver em runtime
âœ… O erro some

-------------------------------------------
6ï¸âƒ£ REGRA DE OURO PRA NUNCA MAIS ERRAR
-------------------------------------------

ðŸ§  REGRA SIMPLES:

- Interface / type â†’ import type
- FunÃ§Ã£o / componente / variÃ¡vel â†’ import normal

Exemplos:

âœ” import type { Product } from '../types/Product'
âœ” import { getAllProducts } from '../services/products'
âœ” import { useState, useEffect } from 'react'

-->
