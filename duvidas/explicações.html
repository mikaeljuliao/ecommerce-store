<!--
================================================================================
D√öVIDA: Por que n√£o usei o StrictMode no in√≠cio do projeto?
================================================================================

No in√≠cio do projeto, optei por N√ÉO usar o StrictMode do React, mesmo ele sendo
o padr√£o do template do Vite + React + TypeScript.

O StrictMode existe apenas em ambiente de desenvolvimento e serve para ajudar
a identificar problemas como:
- efeitos colaterais
- uso de APIs legadas
- padr√µes inseguros de c√≥digo

Por√©m, no React 18, o StrictMode funciona de uma forma espec√≠fica:
ele executa propositalmente algumas partes do c√≥digo DUAS VEZES em desenvolvimento.

Isso inclui:
- useEffect
- inicializa√ß√µes de estado
- algumas l√≥gicas internas
- poss√≠veis chamadas de API

Isso N√ÉO √© bug, √© comportamento intencional do React.

O problema √© que, no in√≠cio do projeto, isso atrapalha o aprendizado e o debug,
principalmente quando estamos lidando com:
- reducers
- regras de neg√≥cio (carrinho)
- chamadas de API
- localStorage

Exemplos de confus√£o que podem acontecer:
- A API parece estar sendo chamada duas vezes
- Um item pode parecer duplicado no carrinho
- Um efeito parece "quebrado", quando na verdade √© o StrictMode

Como o foco inicial do projeto √©:
- entender a l√≥gica
- modelar bem os tipos com TypeScript
- construir a arquitetura corretamente

o StrictMode foi desativado temporariamente.

Importante: isso N√ÉO significa que o StrictMode √© ruim ou n√£o ser√° usado.
Ele pode (e deve) ser reativado depois, quando a l√≥gica estiver s√≥lida
e o comportamento da aplica√ß√£o estiver bem entendido.

================================================================================
RESUMO:
- StrictMode roda c√≥digo duas vezes em dev
- Isso pode gerar confus√£o no in√≠cio
- Foi desativado conscientemente
- Pode ser reativado mais tarde
================================================================================
-->



<!--
================================================================================
D√öVIDA: Por que validar o container antes de usar createRoot?
================================================================================

Ao montar a aplica√ß√£o React, usamos esse c√≥digo:

const container = document.getElementById('root')

O m√©todo getElementById pode retornar dois valores:
- um elemento HTML (HTMLElement)
- ou null, caso o elemento n√£o exista

Ou seja, para o TypeScript, o tipo de container √©:
HTMLElement | null

O problema √© que o React N√ÉO aceita null no createRoot.
Ele exige um elemento HTML v√°lido.

Se passarmos null, a aplica√ß√£o pode:
- quebrar
- n√£o renderizar nada
- gerar erro dif√≠cil de entender

Por isso, fazemos a verifica√ß√£o:

if (!container) {
  throw new Error('Root container missing')
}

Essa verifica√ß√£o serve para:
- garantir que o elemento realmente existe
- interromper a aplica√ß√£o imediatamente se algo estiver errado
- mostrar um erro claro no console

Isso √© muito melhor do que deixar a aplica√ß√£o falhar silenciosamente.

================================================================================
IMPORTANTE PARA O TYPESCRIPT
================================================================================

Depois desse if, o TypeScript entende automaticamente que:
- se o c√≥digo chegou aqui
- ent√£o container N√ÉO √© null

Isso se chama "type narrowing" (estreitamento de tipo).

Antes do if:
HTMLElement | null

Depois do if:
HTMLElement

Isso elimina a necessidade de usar o operador ! (non-null assertion).

================================================================================
COMPARA√á√ÉO COM O OPERADOR !
================================================================================

Forma mais comum (menos segura):

createRoot(document.getElementById('root')!).render(...)

O ! basicamente diz:
"confia em mim, isso nunca ser√° null"

O problema:
- se for null, o erro acontece do mesmo jeito
- o TypeScript deixa de proteger
- o c√≥digo fica menos seguro

Forma usada no projeto (mais profissional):

const container = document.getElementById('root')

if (!container) {
  throw new Error('Root container missing')
}

createRoot(container).render(...)

Essa abordagem:
- √© mais expl√≠cita
- √© mais segura
- mostra maturidade t√©cnica
- facilita debug
- mant√©m o TypeScript trabalhando a favor

================================================================================
ANALOGIA SIMPLES
================================================================================

√â como tentar usar dinheiro sem saber se ele existe:

Errado:
comprarAlgo(dinheiro!)

Correto:
if (!dinheiro) {
  throw new Error('Sem saldo')
}

comprarAlgo(dinheiro)

================================================================================
RESUMO FINAL
================================================================================

- getElementById pode retornar null
- React n√£o aceita null no createRoot
- O if garante seguran√ßa
- O erro fica expl√≠cito
- Evita uso desnecess√°rio do !
- C√≥digo mais profissional e confi√°vel
================================================================================
-->









<!--
================================================================================
TAILWIND CSS ‚Äî PROCESSO COMPLETO DE INSTALA√á√ÉO (VERS√ÉO 3)
================================================================================

Este projeto utiliza Tailwind CSS na vers√£o 3 de forma consciente e intencional.

A vers√£o mais recente (v4) apresentou dificuldades de setup no ambiente com Vite,
principalmente relacionadas √† gera√ß√£o autom√°tica de arquivos de configura√ß√£o
e integra√ß√£o com o bundler.

Como o foco do projeto √© aprendizado, clareza e estabilidade,
a vers√£o 3 foi escolhida por ser:
- amplamente utilizada no mercado
- bem documentada
- est√°vel
- previs√≠vel

================================================================================
PASSO 1 ‚Äî REMO√á√ÉO DO TAILWIND (CASO J√Å EXISTA)
================================================================================

Antes de instalar o Tailwind v3, √© importante remover qualquer res√≠duo
de instala√ß√µes anteriores para evitar conflitos de vers√£o.

Comandos utilizados:

npm uninstall tailwindcss postcss autoprefixer

Ap√≥s isso, verificar e remover manualmente, se existirem:
- tailwind.config.js
- postcss.config.js

Isso garante um ambiente limpo para a nova instala√ß√£o.

================================================================================
PASSO 2 ‚Äî INSTALA√á√ÉO DO TAILWIND CSS v3
================================================================================

Instala√ß√£o expl√≠cita da vers√£o 3:

npm install -D tailwindcss@3 postcss autoprefixer

Ap√≥s a instala√ß√£o, gerar os arquivos de configura√ß√£o:

npx tailwindcss init -p

Esse comando cria automaticamente:
- tailwind.config.js
- postcss.config.js

================================================================================
PASSO 3 ‚Äî CONFIGURA√á√ÉO DO tailwind.config.js
================================================================================

Na vers√£o 3 do Tailwind, o arquivo de configura√ß√£o utiliza CommonJS.
Por isso, √© obrigat√≥rio usar module.exports.

Conte√∫do final do arquivo:

module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

O campo "content" informa ao Tailwind onde procurar as classes
para gerar os estilos corretamente.

================================================================================
PASSO 4 ‚Äî CONFIGURA√á√ÉO DO CSS GLOBAL
================================================================================

No arquivo src/index.css, foram adicionadas as diretivas do Tailwind:

@tailwind base;
@tailwind components;
@tailwind utilities;

Esse arquivo √© importado no main.tsx, garantindo que os estilos
sejam aplicados globalmente na aplica√ß√£o.

================================================================================
PASSO 5 ‚Äî TESTE DE FUNCIONAMENTO
================================================================================

Para confirmar que o Tailwind est√° funcionando corretamente,
foi aplicado um layout simples no componente principal da aplica√ß√£o.

Exemplo utilizado no App.tsx:

function App() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-900 text-white">
      <h1 className="text-3xl font-bold">
        Tailwind v3 funcionando
      </h1>
    </div>
  )
}

export default App

Se o fundo aparecer escuro, o texto branco e centralizado,
significa que o Tailwind est√° configurado corretamente.

================================================================================
CONCLUS√ÉO
================================================================================

A escolha pelo Tailwind CSS v3 n√£o representa atraso tecnol√≥gico,
mas sim uma decis√£o t√©cnica consciente para manter o foco no aprendizado,
evitar problemas de setup e garantir produtividade.

Vers√µes mais novas podem ser avaliadas futuramente,
quando a base do projeto estiver s√≥lida.

================================================================================
-->






















<!--
===========================================
ANOTA√á√ÉO IMPORTANTE ‚Äî TYPESCRIPT + RUNTIME
===========================================

Essa foi, de longe, a parte MAIS CONFUSA do in√≠cio do projeto.
Quase desisti aqui, ent√£o estou documentando com bastante detalhe
pra nunca mais passar por isso.

-------------------------------------------
1Ô∏è‚É£ O QUE SIGNIFICA "EXISTIR EM RUNTIME"?
-------------------------------------------

"Runtime" √© o MOMENTO em que o JavaScript est√° rodando de verdade,
ou seja:

- Quando o navegador abre a aplica√ß√£o
- Quando o c√≥digo j√° virou JavaScript
- Quando N√ÉO EXISTE mais TypeScript

üëâ Runtime = c√≥digo final executando no navegador.

-------------------------------------------
2Ô∏è‚É£ TYPESCRIPT N√ÉO EXISTE EM RUNTIME
-------------------------------------------

TypeScript √© s√≥ uma CAMADA DE DESENVOLVIMENTO.

Antes de rodar no navegador:
- O TypeScript √© COMPILADO
- Interfaces e types S√ÉO APAGADOS
- S√≥ sobra JavaScript

Exemplo:

interface Product {
  id: number
  title: string
}

‚¨áÔ∏è Depois da compila√ß√£o ‚¨áÔ∏è

(NADA)

Isso simplesmente N√ÉO EXISTE mais.

Ou seja:
‚ùå Interface N√ÉO vira vari√°vel
‚ùå Interface N√ÉO vira objeto
‚ùå Interface N√ÉO existe no JavaScript final

Ela s√≥ serve para:
- ajudar o editor
- evitar erros
- dar seguran√ßa de tipo

-------------------------------------------
3Ô∏è‚É£ O ERRO QUE ACONTECEU NO PROJETO
-------------------------------------------

Eu estava importando a interface assim:

import { Product } from '../types/Product'

Isso faz o bundler (Vite) pensar:

"Ok, ent√£o em runtime vai existir algo chamado Product"

MAS N√ÉO EXISTE.

Resultado:
- O Vite tenta encontrar Product no JavaScript
- N√£o acha nada
- A aplica√ß√£o quebra

-------------------------------------------
4Ô∏è‚É£ POR QUE ISSO ACONTECE EM PROJETOS MODERNOS?
-------------------------------------------

Meu projeto usa configura√ß√µes modernas, como:

- Vite
- TypeScript strict
- moduleResolution: "bundler"
- verbatimModuleSyntax: true

Essas configs s√£o MAIS R√çGIDAS de prop√≥sito.

Elas obrigam o dev a deixar claro:
- o que √© TYPE (s√≥ TS)
- o que √© VALUE (existe em runtime)

-------------------------------------------
5Ô∏è‚É£ A SOLU√á√ÉO CORRETA (IMPORTANTE)
-------------------------------------------

Sempre que importar APENAS tipos ou interfaces,
PRECISO usar:

import type { Product } from '../types/Product'

Isso diz claramente:

"Isso aqui √© S√ì PARA O TYPESCRIPT.
N√ÉO tente usar isso no JavaScript final."

Assim:
‚úÖ O TypeScript entende
‚úÖ O Vite n√£o tenta resolver em runtime
‚úÖ O erro some

-------------------------------------------
6Ô∏è‚É£ REGRA DE OURO PRA NUNCA MAIS ERRAR
-------------------------------------------

üß† REGRA SIMPLES:

- Interface / type ‚Üí import type
- Fun√ß√£o / componente / vari√°vel ‚Üí import normal

Exemplos:

‚úî import type { Product } from '../types/Product'
‚úî import { getAllProducts } from '../services/products'
‚úî import { useState, useEffect } from 'react'

-->




















<!--
=====================================================================
ANOTA√á√ÉO DEFINITIVA ‚Äî SERVICE DE PRODUTOS (API + ASYNC + TYPESCRIPT)
=====================================================================

Essa parte do projeto foi uma das mais dif√≠ceis de entender.
N√£o foi falta de capacidade: envolve conceitos FUNDAMENTAIS de
JavaScript ass√≠ncrono + TypeScript moderno + arquitetura de projeto.

Este arquivo N√ÉO √© um componente React.
Ele N√ÉO renderiza nada na tela.
Ele existe apenas para BUSCAR DADOS.

Arquivo:
src/services/products.ts

---------------------------------------------------------------------
1Ô∏è‚É£ O QUE √â ESSE ARQUIVO (IMPORTANTE)
---------------------------------------------------------------------

Esse arquivo √© um SERVICE.

Service √© uma camada respons√°vel APENAS por:
- buscar dados
- tratar erros
- garantir tipos

Ele N√ÉO:
- renderiza UI
- usa JSX
- conhece estado do React

React apenas CONSOME esse service.
Isso √© separa√ß√£o de responsabilidades (padr√£o profissional).

---------------------------------------------------------------------
2Ô∏è‚É£ POR QUE IMPORTAMOS A INTERFACE Product?
---------------------------------------------------------------------

import type { Product } from '../types/Product'

A interface Product √© um CONTRATO de dados.

Ela define exatamente como um produto deve ser:
- id
- title
- price
- description
- category
- image

Isso N√ÉO √© visual.
Isso N√ÉO √© componente.
Isso N√ÉO existe em runtime.

Serve para:
- evitar erro de digita√ß√£o
- evitar erro de tipo
- detectar problemas ANTES de rodar o app

Por isso usamos:
import type ‚Üí deixando claro que √© S√ì TypeScript.

---------------------------------------------------------------------
3Ô∏è‚É£ O QUE √â ESSA API_URL?
---------------------------------------------------------------------

const API_URL = 'https://fakestoreapi.com/products'

Isso √© o ENDERE√áO de onde os dados v√™m.

√â uma API (Application Programming Interface):
- um servidor externo
- que devolve dados
- no formato JSON

N√£o √© banco local.
N√£o √© mock.
√â uma API REST real.

---------------------------------------------------------------------
4Ô∏è‚É£ O QUE SIGNIFICA "async" E POR QUE USAR?
---------------------------------------------------------------------

export async function getAllProducts(): Promise<Product[]> {

Buscar dados da internet N√ÉO acontece na hora.
Pode:
- demorar
- falhar
- n√£o responder

O JavaScript roda em uma √∫nica fila.
Se ele travar esperando a internet, o app congela.

async significa:
"Essa fun√ß√£o come√ßa agora, mas termina depois.
N√£o trave o resto da aplica√ß√£o esperando."

Sem async:
‚ùå tela travaria
‚ùå app congelaria
‚ùå p√©ssima UX

Com async:
‚úÖ c√≥digo continua rodando
‚úÖ UI n√£o trava
‚úÖ experi√™ncia fluida

---------------------------------------------------------------------
5Ô∏è‚É£ O QUE √â Promise<Product[]>?
---------------------------------------------------------------------

Promise significa PROMESSA.

Essa fun√ß√£o N√ÉO retorna os produtos agora.
Ela retorna uma promessa dizendo:

"Quando tudo terminar, eu te entrego um array de Product."

Ou seja:
- agora ‚Üí Promise
- depois ‚Üí Product[]

Isso √© obrigat√≥rio em fun√ß√µes async,
porque os dados ainda N√ÉO EXISTEM no momento da chamada.

Projeto real N√ÉO funciona sem Promise.

---------------------------------------------------------------------
6Ô∏è‚É£ O QUE √â fetch?
---------------------------------------------------------------------

const response = await fetch(API_URL)

fetch √© a fun√ß√£o nativa do JavaScript para:
- fazer requisi√ß√µes HTTP
- buscar dados de APIs

Ele:
- vai at√© a URL
- pede os dados
- aguarda resposta

fetch SEMPRE retorna uma resposta se o servidor respondeu,
mesmo quando essa resposta √© um erro.

---------------------------------------------------------------------
7Ô∏è‚É£ O QUE √â await?
---------------------------------------------------------------------

await significa:
"Espere isso terminar antes de continuar."

Sem await:
- o c√≥digo continuaria sem dados
- tudo quebraria

await fetch(...) =
espera a API responder antes de seguir.

---------------------------------------------------------------------
8Ô∏è‚É£ O QUE √â response?
---------------------------------------------------------------------

response √© o OBJETO de resposta do servidor.

Ele cont√©m:
- status (200, 404, 500, etc)
- headers
- corpo da resposta (ainda n√£o convertido)

Importante:
response N√ÉO s√£o os dados ainda.
response SEMPRE existe se o servidor respondeu.

---------------------------------------------------------------------
9Ô∏è‚É£ O QUE S√ÉO OS C√ìDIGOS HTTP (200, 404, ETC)?
---------------------------------------------------------------------

Esses n√∫meros indicam o resultado da requisi√ß√£o:

200‚Äì299 ‚Üí sucesso
300‚Äì399 ‚Üí redirecionamento
400‚Äì499 ‚Üí erro do cliente
500‚Äì599 ‚Üí erro do servidor

Isso √© padr√£o da web, n√£o do React.

---------------------------------------------------------------------
üîü O QUE √â response.ok?
---------------------------------------------------------------------

response.ok √© um BOOLEAN (true ou false)
calculado automaticamente pelo navegador.

Funciona assim:
- status entre 200 e 299 ‚Üí ok = true
- qualquer outro status ‚Üí ok = false

Ou seja:
response.ok √© um RESUMO do status HTTP.

---------------------------------------------------------------------
1Ô∏è‚É£1Ô∏è‚É£ O QUE SIGNIFICA if (!response.ok)?
---------------------------------------------------------------------

O ! significa "N√ÉO".

if (!response.ok) significa:
"Se a resposta N√ÉO foi bem-sucedida"

Isso N√ÉO quer dizer que response n√£o existe.
Quer dizer:
- o servidor respondeu
- mas respondeu com erro (404, 500, etc)

Por isso N√ÉO usamos if (!response).

---------------------------------------------------------------------
1Ô∏è‚É£2Ô∏è‚É£ O QUE √â throw new Error?
---------------------------------------------------------------------

throw significa "lan√ßar um erro".

throw new Error('mensagem'):

- interrompe a execu√ß√£o da fun√ß√£o
- impede uso de dados inv√°lidos
- avisa quem chamou que algo deu errado

Isso N√ÉO quebra o app sozinho.
O erro pode (e deve) ser tratado depois.

√â a forma correta de tratar erro.

---------------------------------------------------------------------
1Ô∏è‚É£3Ô∏è‚É£ O QUE √â response.json()?
---------------------------------------------------------------------

A API devolve TEXTO em formato JSON.

response.json():
- converte esse texto
- em um objeto JavaScript

Essa convers√£o tamb√©m demora,
por isso usamos await.

---------------------------------------------------------------------
1Ô∏è‚É£4Ô∏è‚É£ O QUE √â 'as Product[]'?
---------------------------------------------------------------------

'as' √© do TypeScript, N√ÉO do JavaScript.

Ele significa:
"Confia em mim, isso tem esse formato."

as Product[] √© uma AFIRMA√á√ÉO de tipo.

Importante:
- N√ÉO valida dados
- N√ÉO altera runtime
- N√ÉO cria objeto

Serve apenas para ensinar o TypeScript.

---------------------------------------------------------------------
1Ô∏è‚É£5Ô∏è‚É£ POR QUE USAR 'as Product[]'?
---------------------------------------------------------------------

O TypeScript N√ÉO sabe o que vem da internet.
Ele n√£o confia automaticamente.

Sem 'as':
- o TS n√£o permite acessar propriedades
- gera erros de tipagem

Com 'as Product[]':
- o TS confia
- libera autocomplete
- evita erros futuros

---------------------------------------------------------------------
1Ô∏è‚É£6Ô∏è‚É£ POR QUE USAR PAR√äNTESES?
---------------------------------------------------------------------

(await response.json()) as Product[]

Significa:
1. espera o JSON
2. depois aplica o tipo

Os par√™nteses evitam ambiguidade de sintaxe.

---------------------------------------------------------------------
1Ô∏è‚É£7Ô∏è‚É£ CONCLUS√ÉO FINAL (IMPORTANTE)
---------------------------------------------------------------------

Esse arquivo N√ÉO √© React.
Ele √© uma camada de servi√ßo.

Ele existe para:
‚úî buscar dados
‚úî tratar erros
‚úî garantir tipos
‚úî manter o c√≥digo organizado

Entender isso foi dif√≠cil,
mas √© conhecimento FUNDAMENTAL
para projetos reais com TypeScript.
-->













<!--
===========================================================
ANOTA√á√ÉO COMPLETA ‚Äî COMPONENTE HOME (PASSO A PASSO)
===========================================================

Arquivo:
src/pages/Home.tsx

Esse arquivo √â um componente React.
Ele N√ÉO √© service.
Ele N√ÉO busca dados direto da API.
Ele √© respons√°vel APENAS por:

‚úî pedir os dados para a camada de service
‚úî controlar estados da interface (UI)
‚úî decidir O QUE aparece na tela e QUANDO

Se algo der errado aqui, N√ÉO √© problema de API,
√© problema de l√≥gica de estado ou renderiza√ß√£o.

-----------------------------------------------------------
1Ô∏è‚É£ IMPORTA√á√ïES ‚Äî O QUE CADA COISA FAZ DE VERDADE
-----------------------------------------------------------

import { useEffect, useState } from 'react'

- useState:
  serve para criar estados que controlam a interface.
  Quando um estado muda, o componente inteiro roda de novo.

- useEffect:
  serve para rodar c√≥digo em momentos espec√≠ficos do ciclo de vida.
  Aqui ele roda QUANDO o componente aparece na tela.

----------------------------------------

import type { Product } from '../types/Product'

- Product √© uma INTERFACE
- interface N√ÉO existe em runtime
- ela serve apenas para o TypeScript verificar tipos

Ela N√ÉO √© componente.
Ela N√ÉO renderiza nada.
Ela √© s√≥ um CONTRATO dizendo:
"um produto precisa ter essas propriedades".

----------------------------------------

import { getAllProducts } from '../services/products'

- Essa fun√ß√£o vem da camada de service.
- Ela √© respons√°vel por:
  ‚úî buscar dados
  ‚úî lidar com async
  ‚úî lidar com erro de API

O React N√ÉO sabe como os dados s√£o buscados.
Isso √© arquitetura correta.

-----------------------------------------------------------
2Ô∏è‚É£ DEFINI√á√ÉO DO COMPONENTE
-----------------------------------------------------------

export function Home() {

Esse √© um componente funcional React.
Tudo dentro dele √© executado:

‚úî no primeiro render
‚úî em todo re-render causado por mudan√ßa de estado

IMPORTANTE:
React n√£o executa linha por linha "uma vez".
Ele REEXECUTA o componente inteiro sempre que um estado muda.

-----------------------------------------------------------
3Ô∏è‚É£ ESTADOS ‚Äî ESSA √â A PARTE MAIS IMPORTANTE
-----------------------------------------------------------

const [products, setProducts] = useState<Product[]>([])

- products guarda os produtos vindos da API.
- come√ßa como array vazio porque:
  no primeiro render, ainda n√£o buscamos nada.

Isso N√ÉO significa erro.
Isso significa "ainda n√£o chegou".

----------------------------------------

const [loading, setLoading] = useState(true)

ESSA PARTE √â CR√çTICA.

loading N√ÉO √© algo autom√°tico.
loading N√ÉO vem da API.
loading N√ÉO vem do React.

loading √© uma DECIS√ÉO DE L√ìGICA.

true significa:
"enquanto isso for true, a interface deve mostrar carregamento".

N√£o existe nada m√°gico aqui.
√â s√≥ um boolean controlando o fluxo da UI.

----------------------------------------

const [error, setError] = useState<string | null>(null)

- error come√ßa como null (nenhum erro).
- se virar string, significa que houve erro.
- essa string ser√° exibida na tela.

-----------------------------------------------------------
4Ô∏è‚É£ useEffect ‚Äî QUANDO O C√ìDIGO RODA
-----------------------------------------------------------

useEffect(() => {

Esse useEffect roda:
‚úî uma √∫nica vez
‚úî quando o componente aparece na tela

Isso acontece porque o array de depend√™ncias √© [].

----------------------------------------

O useEffect N√ÉO pode ser async diretamente.
Por isso criamos uma fun√ß√£o async dentro dele.

-----------------------------------------------------------
5Ô∏è‚É£ FUN√á√ÉO loadProducts ‚Äî O FLUXO REAL
-----------------------------------------------------------

async function loadProducts() {

Essa fun√ß√£o existe para:
‚úî buscar os dados
‚úî tratar erro
‚úî controlar loading

Ela N√ÉO renderiza nada.
Ela s√≥ mexe em estado.

----------------------------------------
try {
----------------------------------------

const data = await getAllProducts()

- getAllProducts retorna uma Promise<Product[]>
- await faz o JavaScript esperar essa Promise resolver
- quando resolve, data vira Product[]

----------------------------------------

setProducts(data)

- isso atualiza o estado products
- setState causa RE-RENDER
- o componente Home vai rodar de novo

----------------------------------------
catch (err) {
----------------------------------------

IMPORTANTE:
err √© o ERRO que aconteceu.

Esse err:
- vem do throw new Error no service
- √© passado automaticamente pelo JavaScript

Mesmo que eu n√£o use err diretamente,
ele PRECISA existir para capturar o erro.

Aqui foi uma decis√£o consciente:
n√£o mostrar erro t√©cnico ao usu√°rio,
apenas uma mensagem gen√©rica.

----------------------------------------

setError('Erro ao carregar produtos')

- define que houve erro
- ativa renderiza√ß√£o condicional de erro

----------------------------------------
finally {
----------------------------------------

setLoading(false)

finally SEMPRE roda:
‚úî se deu certo
‚úî se deu erro
‚úî se algo inesperado aconteceu

Aqui √© onde dizemos:
"n√£o estou mais carregando".

-----------------------------------------------------------
6Ô∏è‚É£ CHAMADA DA FUN√á√ÉO
-----------------------------------------------------------

loadProducts()

Se eu n√£o chamar essa fun√ß√£o,
NADA acontece.

Declarar fun√ß√£o ‚â† executar fun√ß√£o.

-----------------------------------------------------------
7Ô∏è‚É£ RENDERIZA√á√ÉO CONDICIONAL ‚Äî COMO FUNCIONA DE VERDADE
-----------------------------------------------------------

IMPORTANTE:
React l√™ o c√≥digo de CIMA PARA BAIXO.
Quando encontra um return, ele PARA.

----------------------------------------
PRIORIDADE 1 ‚Äî LOADING
----------------------------------------

if (loading) {
  return <p>Carregando...</p>
}

Isso N√ÉO √© especial.
Isso N√ÉO √© React avan√ßado.
Isso √© JavaScript puro.

Enquanto loading = true:
- o componente retorna aqui
- nada abaixo √© executado
- produtos e erro N√ÉO existem na UI

----------------------------------------
PRIORIDADE 2 ‚Äî ERRO
----------------------------------------

if (error) {
  return <p>{error}</p>
}

Esse bloco s√≥ √© avaliado se loading for false.

Se error tiver valor:
- renderiza erro
- encerra o componente aqui

----------------------------------------
PRIORIDADE 3 ‚Äî SUCESSO
----------------------------------------

Se chegou aqui:
‚úî loading √© false
‚úî error √© null
‚úî products tem dados

Agora sim renderizamos os produtos.

-----------------------------------------------------------
8Ô∏è‚É£ RENDERIZA√á√ÉO DOS PRODUTOS
-----------------------------------------------------------

{products.map(product => (

- map percorre o array products
- product √© um Product (tipado)
- React exige uma key √∫nica

----------------------------------------

key={product.id}

- evita bugs de renderiza√ß√£o
- melhora performance
- √© obrigat√≥rio em listas

----------------------------------------

<img src={product.image} />

- imagem vem da API
- j√° validada e tipada

----------------------------------------

{product.title}
{product.price}

Nada disso seria poss√≠vel se:
- loading n√£o fosse controlado
- erro n√£o fosse tratado
- estados n√£o fossem bem definidos

-----------------------------------------------------------
9Ô∏è‚É£ RESUMO FINAL PRA EU DO FUTURO
-----------------------------------------------------------

Esse componente N√ÉO √© simples,
mas ele segue l√≥gica clara.

‚úî React N√ÉO busca dados
‚úî estados controlam tudo
‚úî loading √© s√≥ um boolean
‚úî erro √© s√≥ um estado
‚úî a ordem dos if define prioridade
‚úî return encerra renderiza√ß√£o

Se eu travar aqui de novo:
üëâ lembrar que React s√≥ reage a estado
üëâ lembrar que setState causa re-render
üëâ lembrar que n√£o existe m√°gica
üëâ lembrar que EU controlo o fluxo







-->

























<!--
=====================================================
ANOTA√á√ÉO COMPLETA ‚Äî BASE LAYOUT, CHILDREN E TIPAGEM
=====================================================

Essa anota√ß√£o existe para EU NO FUTURO entender:
- por que foi criado o BaseLayout
- por que usei children
- por que usei interface
- por que isso N√ÉO √© exagero
- e por que essa estrutura faz sentido em projeto real

Essa parte CONFUNDE MESMO no come√ßo.
N√£o √© √≥bvia.
Ent√£o a explica√ß√£o precisa ser completa.

-----------------------------------------------------
1Ô∏è‚É£ O QUE √â import type { ReactNode } from 'react'
-----------------------------------------------------

ReactNode √© APENAS um tipo do TypeScript.
Ele N√ÉO existe quando a aplica√ß√£o est√° rodando (runtime).

ReactNode representa:
- qualquer coisa que o React consegue renderizar
- JSX (<div>, <Component />)
- texto
- n√∫mero
- null
- arrays de JSX

Por isso uso:
import type { ReactNode } from 'react'

Isso diz claramente:
"isso aqui √© s√≥ tipagem, n√£o √© c√≥digo real".

Se eu importar sem 'type', o ESLint reclama,
porque ele tenta achar isso no JavaScript final,
mas ReactNode N√ÉO existe em runtime.

-----------------------------------------------------
2Ô∏è‚É£ O QUE √â children NO REACT
-----------------------------------------------------

children N√ÉO √© algo que eu criei.
children √© um comportamento padr√£o do React.

Tudo que eu coloco ENTRE as tags de um componente:

<BaseLayout>
  <Home />
</BaseLayout>

Automaticamente vira:

props.children = <Home />

Ou seja:
children √© simplesmente o CONTE√öDO INTERNO do componente.

-----------------------------------------------------
3Ô∏è‚É£ O QUE √â A INTERFACE BaseLayoutProps
-----------------------------------------------------

interface BaseLayoutProps {
  children: ReactNode
}

Essa interface √© um CONTRATO.

Ela diz:
"Se algu√©m usar o BaseLayout,
√© OBRIGAT√ìRIO passar children,
e esse children precisa ser algo renderiz√°vel."

A interface N√ÉO cria props.
A interface N√ÉO passa valores.
Ela s√≥ serve para o TypeScript validar.

-----------------------------------------------------
4Ô∏è‚É£ O QUE SIGNIFICA ESSA SINTAXE ESTRANHA
-----------------------------------------------------

export function BaseLayout({ children }: BaseLayoutProps)

Isso mistura DUAS coisas diferentes:

1) JavaScript ‚Üí desestrutura√ß√£o
2) TypeScript ‚Üí tipagem

-----------------------------------------------------
5Ô∏è‚É£ QUEBRANDO ESSA LINHA EM PARTES
-----------------------------------------------------

Parte 1 ‚Äî { children }

Isso √© desestrutura√ß√£o.
Significa:
"pegue a propriedade children de props".

√â o mesmo que:
props.children

Parte 2 ‚Äî : BaseLayoutProps

Isso √© TypeScript dizendo:
"as props desse componente precisam seguir essa interface".

Ou seja:
- precisa existir children
- children precisa ser ReactNode

Juntando tudo:
"Recebo props, valido com BaseLayoutProps e uso s√≥ o children".

-----------------------------------------------------
6Ô∏è‚É£ CHILDREN DA INTERFACE E CHILDREN DO COMPONENTE
-----------------------------------------------------

Eles N√ÉO s√£o diferentes.

S√£o a MESMA coisa vista em momentos diferentes:

- Interface ‚Üí define a regra
- Fun√ß√£o ‚Üí recebe o valor
- JSX ‚Üí renderiza

Tudo aponta para o mesmo children.

-----------------------------------------------------
7Ô∏è‚É£ POR QUE N√ÉO USAR props.children DIRETO?
-----------------------------------------------------

Eu poderia escrever assim:

export function BaseLayout(props: BaseLayoutProps) {
  return <main>{props.children}</main>
}

Isso FUNCIONA 100%.

A vers√£o com:
({ children }: BaseLayoutProps)

√©:
- mais limpa
- mais leg√≠vel
- mais comum no mercado

Por isso deixei assim.

-----------------------------------------------------
8Ô∏è‚É£ O QUE ACONTECE NO RETURN
-----------------------------------------------------

<main>
  {children}
</main>

Isso significa:
"Renderize aqui dentro tudo que veio de fora".

Se eu fizer:

<BaseLayout>
  <Home />
</BaseLayout>

O resultado final ser√°:

<header />
<main>
  <Home />
</main>
<footer />

O layout define a ESTRUTURA.
A p√°gina define o CONTE√öDO.

-----------------------------------------------------
9Ô∏è‚É£ O PROBLEMA DA SOLU√á√ÉO ‚ÄúF√ÅCIL‚Äù
-----------------------------------------------------

Existe uma forma mais simples de fazer isso,
que seria colocar tudo direto no App.tsx:

function App() {
  return (
    <>
      <Header />
      <main>
        <Home />
      </main>
      <Footer />
    </>
  )
}

Isso FUNCIONA.
N√£o tem erro t√©cnico nenhum.

Se o projeto fosse pequeno,
ou tivesse s√≥ uma p√°gina,
isso j√° resolveria.

-----------------------------------------------------
üîü ONDE A SOLU√á√ÉO F√ÅCIL COME√áA A DAR PROBLEMA
-----------------------------------------------------

O problema aparece quando o projeto cresce.

Hoje existe apenas a Home,
mas amanh√£ podem existir p√°ginas como:

- /produto/:id
- /login
- /checkout

Todas essas p√°ginas precisam:
- Header
- Footer
- SEO
- <main>

Se eu usar a solu√ß√£o f√°cil,
vou precisar copiar e colar essa estrutura
ou deixar o App.tsx gigante e confuso.

Isso gera:
- c√≥digo duplicado
- manuten√ß√£o dif√≠cil
- mais chance de erro no futuro

-----------------------------------------------------
1Ô∏è‚É£1Ô∏è‚É£ O QUE O BaseLayout RESOLVE DE VERDADE
-----------------------------------------------------

O BaseLayout resolve problemas REAIS de arquitetura.

Com BaseLayout:

<BaseLayout>
  <Home />
</BaseLayout>

Depois:

<BaseLayout>
  <ProductPage />
</BaseLayout>

Depois:

<BaseLayout>
  <Checkout />
</BaseLayout>

‚û°Ô∏è A estrutura √© sempre a mesma
‚û°Ô∏è S√≥ o conte√∫do muda
‚û°Ô∏è Nenhuma repeti√ß√£o de Header, Main e Footer

-----------------------------------------------------
1Ô∏è‚É£2Ô∏è‚É£ CONCLUS√ÉO PRA EU NO FUTURO
-----------------------------------------------------

A solu√ß√£o f√°cil resolve o AGORA.
O BaseLayout resolve o FUTURO.

Ele existe para:
- reaproveitar estrutura
- manter o c√≥digo organizado
- facilitar manuten√ß√£o
- garantir sem√¢ntica e SEO
- permitir crescimento sem bagun√ßa

Por isso faz sentido usar:
- children
- interface
- ReactNode
- import type

Mesmo parecendo mais c√≥digo no come√ßo.

-----------------------------------------------------
1Ô∏è‚É£3Ô∏è‚É£ REGRA DE OURO PRA N√ÉO ESQUECER
-----------------------------------------------------

- children = conte√∫do interno
- ReactNode = tudo que pode ser renderizado
- interface = contrato
- import type = s√≥ tipagem
- BaseLayout = estrutura fixa
- p√°ginas = conte√∫do vari√°vel

Se eu estiver confuso no futuro,
lembra disso:

"Layout envolve p√°ginas,
p√°ginas N√ÉO envolvem layout."
-->
