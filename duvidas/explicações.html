<!--
================================================================================
DÃšVIDA: Por que nÃ£o usei o StrictMode no inÃ­cio do projeto?
================================================================================

No inÃ­cio do projeto, optei por NÃƒO usar o StrictMode do React, mesmo ele sendo
o padrÃ£o do template do Vite + React + TypeScript.

O StrictMode existe apenas em ambiente de desenvolvimento e serve para ajudar
a identificar problemas como:
- efeitos colaterais
- uso de APIs legadas
- padrÃµes inseguros de cÃ³digo

PorÃ©m, no React 18, o StrictMode funciona de uma forma especÃ­fica:
ele executa propositalmente algumas partes do cÃ³digo DUAS VEZES em desenvolvimento.

Isso inclui:
- useEffect
- inicializaÃ§Ãµes de estado
- algumas lÃ³gicas internas
- possÃ­veis chamadas de API

Isso NÃƒO Ã© bug, Ã© comportamento intencional do React.

O problema Ã© que, no inÃ­cio do projeto, isso atrapalha o aprendizado e o debug,
principalmente quando estamos lidando com:
- reducers
- regras de negÃ³cio (carrinho)
- chamadas de API
- localStorage

Exemplos de confusÃ£o que podem acontecer:
- A API parece estar sendo chamada duas vezes
- Um item pode parecer duplicado no carrinho
- Um efeito parece "quebrado", quando na verdade Ã© o StrictMode

Como o foco inicial do projeto Ã©:
- entender a lÃ³gica
- modelar bem os tipos com TypeScript
- construir a arquitetura corretamente

o StrictMode foi desativado temporariamente.

Importante: isso NÃƒO significa que o StrictMode Ã© ruim ou nÃ£o serÃ¡ usado.
Ele pode (e deve) ser reativado depois, quando a lÃ³gica estiver sÃ³lida
e o comportamento da aplicaÃ§Ã£o estiver bem entendido.

================================================================================
RESUMO:
- StrictMode roda cÃ³digo duas vezes em dev
- Isso pode gerar confusÃ£o no inÃ­cio
- Foi desativado conscientemente
- Pode ser reativado mais tarde
================================================================================
-->



<!--
================================================================================
DÃšVIDA: Por que validar o container antes de usar createRoot?
================================================================================

Ao montar a aplicaÃ§Ã£o React, usamos esse cÃ³digo:

const container = document.getElementById('root')

O mÃ©todo getElementById pode retornar dois valores:
- um elemento HTML (HTMLElement)
- ou null, caso o elemento nÃ£o exista

Ou seja, para o TypeScript, o tipo de container Ã©:
HTMLElement | null

O problema Ã© que o React NÃƒO aceita null no createRoot.
Ele exige um elemento HTML vÃ¡lido.

Se passarmos null, a aplicaÃ§Ã£o pode:
- quebrar
- nÃ£o renderizar nada
- gerar erro difÃ­cil de entender

Por isso, fazemos a verificaÃ§Ã£o:

if (!container) {
  throw new Error('Root container missing')
}

Essa verificaÃ§Ã£o serve para:
- garantir que o elemento realmente existe
- interromper a aplicaÃ§Ã£o imediatamente se algo estiver errado
- mostrar um erro claro no console

Isso Ã© muito melhor do que deixar a aplicaÃ§Ã£o falhar silenciosamente.

================================================================================
IMPORTANTE PARA O TYPESCRIPT
================================================================================

Depois desse if, o TypeScript entende automaticamente que:
- se o cÃ³digo chegou aqui
- entÃ£o container NÃƒO Ã© null

Isso se chama "type narrowing" (estreitamento de tipo).

Antes do if:
HTMLElement | null

Depois do if:
HTMLElement

Isso elimina a necessidade de usar o operador ! (non-null assertion).

================================================================================
COMPARAÃ‡ÃƒO COM O OPERADOR !
================================================================================

Forma mais comum (menos segura):

createRoot(document.getElementById('root')!).render(...)

O ! basicamente diz:
"confia em mim, isso nunca serÃ¡ null"

O problema:
- se for null, o erro acontece do mesmo jeito
- o TypeScript deixa de proteger
- o cÃ³digo fica menos seguro

Forma usada no projeto (mais profissional):

const container = document.getElementById('root')

if (!container) {
  throw new Error('Root container missing')
}

createRoot(container).render(...)

Essa abordagem:
- Ã© mais explÃ­cita
- Ã© mais segura
- mostra maturidade tÃ©cnica
- facilita debug
- mantÃ©m o TypeScript trabalhando a favor

================================================================================
ANALOGIA SIMPLES
================================================================================

Ã‰ como tentar usar dinheiro sem saber se ele existe:

Errado:
comprarAlgo(dinheiro!)

Correto:
if (!dinheiro) {
  throw new Error('Sem saldo')
}

comprarAlgo(dinheiro)

================================================================================
RESUMO FINAL
================================================================================

- getElementById pode retornar null
- React nÃ£o aceita null no createRoot
- O if garante seguranÃ§a
- O erro fica explÃ­cito
- Evita uso desnecessÃ¡rio do !
- CÃ³digo mais profissional e confiÃ¡vel
================================================================================
-->









<!--
================================================================================
TAILWIND CSS â€” PROCESSO COMPLETO DE INSTALAÃ‡ÃƒO (VERSÃƒO 3)
================================================================================

Este projeto utiliza Tailwind CSS na versÃ£o 3 de forma consciente e intencional.

A versÃ£o mais recente (v4) apresentou dificuldades de setup no ambiente com Vite,
principalmente relacionadas Ã  geraÃ§Ã£o automÃ¡tica de arquivos de configuraÃ§Ã£o
e integraÃ§Ã£o com o bundler.

Como o foco do projeto Ã© aprendizado, clareza e estabilidade,
a versÃ£o 3 foi escolhida por ser:
- amplamente utilizada no mercado
- bem documentada
- estÃ¡vel
- previsÃ­vel

================================================================================
PASSO 1 â€” REMOÃ‡ÃƒO DO TAILWIND (CASO JÃ EXISTA)
================================================================================

Antes de instalar o Tailwind v3, Ã© importante remover qualquer resÃ­duo
de instalaÃ§Ãµes anteriores para evitar conflitos de versÃ£o.

Comandos utilizados:

npm uninstall tailwindcss postcss autoprefixer

ApÃ³s isso, verificar e remover manualmente, se existirem:
- tailwind.config.js
- postcss.config.js

Isso garante um ambiente limpo para a nova instalaÃ§Ã£o.

================================================================================
PASSO 2 â€” INSTALAÃ‡ÃƒO DO TAILWIND CSS v3
================================================================================

InstalaÃ§Ã£o explÃ­cita da versÃ£o 3:

npm install -D tailwindcss@3 postcss autoprefixer

ApÃ³s a instalaÃ§Ã£o, gerar os arquivos de configuraÃ§Ã£o:

npx tailwindcss init -p

Esse comando cria automaticamente:
- tailwind.config.js
- postcss.config.js

================================================================================
PASSO 3 â€” CONFIGURAÃ‡ÃƒO DO tailwind.config.js
================================================================================

Na versÃ£o 3 do Tailwind, o arquivo de configuraÃ§Ã£o utiliza CommonJS.
Por isso, Ã© obrigatÃ³rio usar module.exports.

ConteÃºdo final do arquivo:

module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

O campo "content" informa ao Tailwind onde procurar as classes
para gerar os estilos corretamente.

================================================================================
PASSO 4 â€” CONFIGURAÃ‡ÃƒO DO CSS GLOBAL
================================================================================

No arquivo src/index.css, foram adicionadas as diretivas do Tailwind:

@tailwind base;
@tailwind components;
@tailwind utilities;

Esse arquivo Ã© importado no main.tsx, garantindo que os estilos
sejam aplicados globalmente na aplicaÃ§Ã£o.

================================================================================
PASSO 5 â€” TESTE DE FUNCIONAMENTO
================================================================================

Para confirmar que o Tailwind estÃ¡ funcionando corretamente,
foi aplicado um layout simples no componente principal da aplicaÃ§Ã£o.

Exemplo utilizado no App.tsx:

function App() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-900 text-white">
      <h1 className="text-3xl font-bold">
        Tailwind v3 funcionando
      </h1>
    </div>
  )
}

export default App

Se o fundo aparecer escuro, o texto branco e centralizado,
significa que o Tailwind estÃ¡ configurado corretamente.

================================================================================
CONCLUSÃƒO
================================================================================

A escolha pelo Tailwind CSS v3 nÃ£o representa atraso tecnolÃ³gico,
mas sim uma decisÃ£o tÃ©cnica consciente para manter o foco no aprendizado,
evitar problemas de setup e garantir produtividade.

VersÃµes mais novas podem ser avaliadas futuramente,
quando a base do projeto estiver sÃ³lida.

================================================================================
-->






















<!--
===========================================
ANOTAÃ‡ÃƒO IMPORTANTE â€” TYPESCRIPT + RUNTIME
===========================================

Essa foi, de longe, a parte MAIS CONFUSA do inÃ­cio do projeto.
Quase desisti aqui, entÃ£o estou documentando com bastante detalhe
pra nunca mais passar por isso.

-------------------------------------------
1ï¸âƒ£ O QUE SIGNIFICA "EXISTIR EM RUNTIME"?
-------------------------------------------

"Runtime" Ã© o MOMENTO em que o JavaScript estÃ¡ rodando de verdade,
ou seja:

- Quando o navegador abre a aplicaÃ§Ã£o
- Quando o cÃ³digo jÃ¡ virou JavaScript
- Quando NÃƒO EXISTE mais TypeScript

ğŸ‘‰ Runtime = cÃ³digo final executando no navegador.

-------------------------------------------
2ï¸âƒ£ TYPESCRIPT NÃƒO EXISTE EM RUNTIME
-------------------------------------------

TypeScript Ã© sÃ³ uma CAMADA DE DESENVOLVIMENTO.

Antes de rodar no navegador:
- O TypeScript Ã© COMPILADO
- Interfaces e types SÃƒO APAGADOS
- SÃ³ sobra JavaScript

Exemplo:

interface Product {
  id: number
  title: string
}

â¬‡ï¸ Depois da compilaÃ§Ã£o â¬‡ï¸

(NADA)

Isso simplesmente NÃƒO EXISTE mais.

Ou seja:
âŒ Interface NÃƒO vira variÃ¡vel
âŒ Interface NÃƒO vira objeto
âŒ Interface NÃƒO existe no JavaScript final

Ela sÃ³ serve para:
- ajudar o editor
- evitar erros
- dar seguranÃ§a de tipo

-------------------------------------------
3ï¸âƒ£ O ERRO QUE ACONTECEU NO PROJETO
-------------------------------------------

Eu estava importando a interface assim:

import { Product } from '../types/Product'

Isso faz o bundler (Vite) pensar:

"Ok, entÃ£o em runtime vai existir algo chamado Product"

MAS NÃƒO EXISTE.

Resultado:
- O Vite tenta encontrar Product no JavaScript
- NÃ£o acha nada
- A aplicaÃ§Ã£o quebra

-------------------------------------------
4ï¸âƒ£ POR QUE ISSO ACONTECE EM PROJETOS MODERNOS?
-------------------------------------------

Meu projeto usa configuraÃ§Ãµes modernas, como:

- Vite
- TypeScript strict
- moduleResolution: "bundler"
- verbatimModuleSyntax: true

Essas configs sÃ£o MAIS RÃGIDAS de propÃ³sito.

Elas obrigam o dev a deixar claro:
- o que Ã© TYPE (sÃ³ TS)
- o que Ã© VALUE (existe em runtime)

-------------------------------------------
5ï¸âƒ£ A SOLUÃ‡ÃƒO CORRETA (IMPORTANTE)
-------------------------------------------

Sempre que importar APENAS tipos ou interfaces,
PRECISO usar:

import type { Product } from '../types/Product'

Isso diz claramente:

"Isso aqui Ã© SÃ“ PARA O TYPESCRIPT.
NÃƒO tente usar isso no JavaScript final."

Assim:
âœ… O TypeScript entende
âœ… O Vite nÃ£o tenta resolver em runtime
âœ… O erro some

-------------------------------------------
6ï¸âƒ£ REGRA DE OURO PRA NUNCA MAIS ERRAR
-------------------------------------------

ğŸ§  REGRA SIMPLES:

- Interface / type â†’ import type
- FunÃ§Ã£o / componente / variÃ¡vel â†’ import normal

Exemplos:

âœ” import type { Product } from '../types/Product'
âœ” import { getAllProducts } from '../services/products'
âœ” import { useState, useEffect } from 'react'

-->




















<!--
=====================================================================
ANOTAÃ‡ÃƒO DEFINITIVA â€” SERVICE DE PRODUTOS (API + ASYNC + TYPESCRIPT)
=====================================================================

Essa parte do projeto foi uma das mais difÃ­ceis de entender.
NÃ£o foi falta de capacidade: envolve conceitos FUNDAMENTAIS de
JavaScript assÃ­ncrono + TypeScript moderno + arquitetura de projeto.

Este arquivo NÃƒO Ã© um componente React.
Ele NÃƒO renderiza nada na tela.
Ele existe apenas para BUSCAR DADOS.

Arquivo:
src/services/products.ts

---------------------------------------------------------------------
1ï¸âƒ£ O QUE Ã‰ ESSE ARQUIVO (IMPORTANTE)
---------------------------------------------------------------------

Esse arquivo Ã© um SERVICE.

Service Ã© uma camada responsÃ¡vel APENAS por:
- buscar dados
- tratar erros
- garantir tipos

Ele NÃƒO:
- renderiza UI
- usa JSX
- conhece estado do React

React apenas CONSOME esse service.
Isso Ã© separaÃ§Ã£o de responsabilidades (padrÃ£o profissional).

---------------------------------------------------------------------
2ï¸âƒ£ POR QUE IMPORTAMOS A INTERFACE Product?
---------------------------------------------------------------------

import type { Product } from '../types/Product'

A interface Product Ã© um CONTRATO de dados.

Ela define exatamente como um produto deve ser:
- id
- title
- price
- description
- category
- image

Isso NÃƒO Ã© visual.
Isso NÃƒO Ã© componente.
Isso NÃƒO existe em runtime.

Serve para:
- evitar erro de digitaÃ§Ã£o
- evitar erro de tipo
- detectar problemas ANTES de rodar o app

Por isso usamos:
import type â†’ deixando claro que Ã© SÃ“ TypeScript.

---------------------------------------------------------------------
3ï¸âƒ£ O QUE Ã‰ ESSA API_URL?
---------------------------------------------------------------------

const API_URL = 'https://fakestoreapi.com/products'

Isso Ã© o ENDEREÃ‡O de onde os dados vÃªm.

Ã‰ uma API (Application Programming Interface):
- um servidor externo
- que devolve dados
- no formato JSON

NÃ£o Ã© banco local.
NÃ£o Ã© mock.
Ã‰ uma API REST real.

---------------------------------------------------------------------
4ï¸âƒ£ O QUE SIGNIFICA "async" E POR QUE USAR?
---------------------------------------------------------------------

export async function getAllProducts(): Promise<Product[]> {

Buscar dados da internet NÃƒO acontece na hora.
Pode:
- demorar
- falhar
- nÃ£o responder

O JavaScript roda em uma Ãºnica fila.
Se ele travar esperando a internet, o app congela.

async significa:
"Essa funÃ§Ã£o comeÃ§a agora, mas termina depois.
NÃ£o trave o resto da aplicaÃ§Ã£o esperando."

Sem async:
âŒ tela travaria
âŒ app congelaria
âŒ pÃ©ssima UX

Com async:
âœ… cÃ³digo continua rodando
âœ… UI nÃ£o trava
âœ… experiÃªncia fluida

---------------------------------------------------------------------
5ï¸âƒ£ O QUE Ã‰ Promise<Product[]>?
---------------------------------------------------------------------

Promise significa PROMESSA.

Essa funÃ§Ã£o NÃƒO retorna os produtos agora.
Ela retorna uma promessa dizendo:

"Quando tudo terminar, eu te entrego um array de Product."

Ou seja:
- agora â†’ Promise
- depois â†’ Product[]

Isso Ã© obrigatÃ³rio em funÃ§Ãµes async,
porque os dados ainda NÃƒO EXISTEM no momento da chamada.

Projeto real NÃƒO funciona sem Promise.

---------------------------------------------------------------------
6ï¸âƒ£ O QUE Ã‰ fetch?
---------------------------------------------------------------------

const response = await fetch(API_URL)

fetch Ã© a funÃ§Ã£o nativa do JavaScript para:
- fazer requisiÃ§Ãµes HTTP
- buscar dados de APIs

Ele:
- vai atÃ© a URL
- pede os dados
- aguarda resposta

fetch SEMPRE retorna uma resposta se o servidor respondeu,
mesmo quando essa resposta Ã© um erro.

---------------------------------------------------------------------
7ï¸âƒ£ O QUE Ã‰ await?
---------------------------------------------------------------------

await significa:
"Espere isso terminar antes de continuar."

Sem await:
- o cÃ³digo continuaria sem dados
- tudo quebraria

await fetch(...) =
espera a API responder antes de seguir.

---------------------------------------------------------------------
8ï¸âƒ£ O QUE Ã‰ response?
---------------------------------------------------------------------

response Ã© o OBJETO de resposta do servidor.

Ele contÃ©m:
- status (200, 404, 500, etc)
- headers
- corpo da resposta (ainda nÃ£o convertido)

Importante:
response NÃƒO sÃ£o os dados ainda.
response SEMPRE existe se o servidor respondeu.

---------------------------------------------------------------------
9ï¸âƒ£ O QUE SÃƒO OS CÃ“DIGOS HTTP (200, 404, ETC)?
---------------------------------------------------------------------

Esses nÃºmeros indicam o resultado da requisiÃ§Ã£o:

200â€“299 â†’ sucesso
300â€“399 â†’ redirecionamento
400â€“499 â†’ erro do cliente
500â€“599 â†’ erro do servidor

Isso Ã© padrÃ£o da web, nÃ£o do React.

---------------------------------------------------------------------
ğŸ”Ÿ O QUE Ã‰ response.ok?
---------------------------------------------------------------------

response.ok Ã© um BOOLEAN (true ou false)
calculado automaticamente pelo navegador.

Funciona assim:
- status entre 200 e 299 â†’ ok = true
- qualquer outro status â†’ ok = false

Ou seja:
response.ok Ã© um RESUMO do status HTTP.

---------------------------------------------------------------------
1ï¸âƒ£1ï¸âƒ£ O QUE SIGNIFICA if (!response.ok)?
---------------------------------------------------------------------

O ! significa "NÃƒO".

if (!response.ok) significa:
"Se a resposta NÃƒO foi bem-sucedida"

Isso NÃƒO quer dizer que response nÃ£o existe.
Quer dizer:
- o servidor respondeu
- mas respondeu com erro (404, 500, etc)

Por isso NÃƒO usamos if (!response).

---------------------------------------------------------------------
1ï¸âƒ£2ï¸âƒ£ O QUE Ã‰ throw new Error?
---------------------------------------------------------------------

throw significa "lanÃ§ar um erro".

throw new Error('mensagem'):

- interrompe a execuÃ§Ã£o da funÃ§Ã£o
- impede uso de dados invÃ¡lidos
- avisa quem chamou que algo deu errado

Isso NÃƒO quebra o app sozinho.
O erro pode (e deve) ser tratado depois.

Ã‰ a forma correta de tratar erro.

---------------------------------------------------------------------
1ï¸âƒ£3ï¸âƒ£ O QUE Ã‰ response.json()?
---------------------------------------------------------------------

A API devolve TEXTO em formato JSON.

response.json():
- converte esse texto
- em um objeto JavaScript

Essa conversÃ£o tambÃ©m demora,
por isso usamos await.

---------------------------------------------------------------------
1ï¸âƒ£4ï¸âƒ£ O QUE Ã‰ 'as Product[]'?
---------------------------------------------------------------------

'as' Ã© do TypeScript, NÃƒO do JavaScript.

Ele significa:
"Confia em mim, isso tem esse formato."

as Product[] Ã© uma AFIRMAÃ‡ÃƒO de tipo.

Importante:
- NÃƒO valida dados
- NÃƒO altera runtime
- NÃƒO cria objeto

Serve apenas para ensinar o TypeScript.

---------------------------------------------------------------------
1ï¸âƒ£5ï¸âƒ£ POR QUE USAR 'as Product[]'?
---------------------------------------------------------------------

O TypeScript NÃƒO sabe o que vem da internet.
Ele nÃ£o confia automaticamente.

Sem 'as':
- o TS nÃ£o permite acessar propriedades
- gera erros de tipagem

Com 'as Product[]':
- o TS confia
- libera autocomplete
- evita erros futuros

---------------------------------------------------------------------
1ï¸âƒ£6ï¸âƒ£ POR QUE USAR PARÃŠNTESES?
---------------------------------------------------------------------

(await response.json()) as Product[]

Significa:
1. espera o JSON
2. depois aplica o tipo

Os parÃªnteses evitam ambiguidade de sintaxe.

---------------------------------------------------------------------
1ï¸âƒ£7ï¸âƒ£ CONCLUSÃƒO FINAL (IMPORTANTE)
---------------------------------------------------------------------

Esse arquivo NÃƒO Ã© React.
Ele Ã© uma camada de serviÃ§o.

Ele existe para:
âœ” buscar dados
âœ” tratar erros
âœ” garantir tipos
âœ” manter o cÃ³digo organizado

Entender isso foi difÃ­cil,
mas Ã© conhecimento FUNDAMENTAL
para projetos reais com TypeScript.
-->
