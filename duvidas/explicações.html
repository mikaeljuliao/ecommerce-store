<!--
================================================================================
D√öVIDA: Por que n√£o usei o StrictMode no in√≠cio do projeto?
================================================================================

No in√≠cio do projeto, optei por N√ÉO usar o StrictMode do React, mesmo ele sendo
o padr√£o do template do Vite + React + TypeScript.

O StrictMode existe apenas em ambiente de desenvolvimento e serve para ajudar
a identificar problemas como:
- efeitos colaterais
- uso de APIs legadas
- padr√µes inseguros de c√≥digo

Por√©m, no React 18, o StrictMode funciona de uma forma espec√≠fica:
ele executa propositalmente algumas partes do c√≥digo DUAS VEZES em desenvolvimento.

Isso inclui:
- useEffect
- inicializa√ß√µes de estado
- algumas l√≥gicas internas
- poss√≠veis chamadas de API

Isso N√ÉO √© bug, √© comportamento intencional do React.

O problema √© que, no in√≠cio do projeto, isso atrapalha o aprendizado e o debug,
principalmente quando estamos lidando com:
- reducers
- regras de neg√≥cio (carrinho)
- chamadas de API
- localStorage

Exemplos de confus√£o que podem acontecer:
- A API parece estar sendo chamada duas vezes
- Um item pode parecer duplicado no carrinho
- Um efeito parece "quebrado", quando na verdade √© o StrictMode

Como o foco inicial do projeto √©:
- entender a l√≥gica
- modelar bem os tipos com TypeScript
- construir a arquitetura corretamente

o StrictMode foi desativado temporariamente.

Importante: isso N√ÉO significa que o StrictMode √© ruim ou n√£o ser√° usado.
Ele pode (e deve) ser reativado depois, quando a l√≥gica estiver s√≥lida
e o comportamento da aplica√ß√£o estiver bem entendido.

================================================================================
RESUMO:
- StrictMode roda c√≥digo duas vezes em dev
- Isso pode gerar confus√£o no in√≠cio
- Foi desativado conscientemente
- Pode ser reativado mais tarde
================================================================================
-->



<!--
================================================================================
D√öVIDA: Por que validar o container antes de usar createRoot?
================================================================================

Ao montar a aplica√ß√£o React, usamos esse c√≥digo:

const container = document.getElementById('root')

O m√©todo getElementById pode retornar dois valores:
- um elemento HTML (HTMLElement)
- ou null, caso o elemento n√£o exista

Ou seja, para o TypeScript, o tipo de container √©:
HTMLElement | null

O problema √© que o React N√ÉO aceita null no createRoot.
Ele exige um elemento HTML v√°lido.

Se passarmos null, a aplica√ß√£o pode:
- quebrar
- n√£o renderizar nada
- gerar erro dif√≠cil de entender

Por isso, fazemos a verifica√ß√£o:

if (!container) {
  throw new Error('Root container missing')
}

Essa verifica√ß√£o serve para:
- garantir que o elemento realmente existe
- interromper a aplica√ß√£o imediatamente se algo estiver errado
- mostrar um erro claro no console

Isso √© muito melhor do que deixar a aplica√ß√£o falhar silenciosamente.

================================================================================
IMPORTANTE PARA O TYPESCRIPT
================================================================================

Depois desse if, o TypeScript entende automaticamente que:
- se o c√≥digo chegou aqui
- ent√£o container N√ÉO √© null

Isso se chama "type narrowing" (estreitamento de tipo).

Antes do if:
HTMLElement | null

Depois do if:
HTMLElement

Isso elimina a necessidade de usar o operador ! (non-null assertion).

================================================================================
COMPARA√á√ÉO COM O OPERADOR !
================================================================================

Forma mais comum (menos segura):

createRoot(document.getElementById('root')!).render(...)

O ! basicamente diz:
"confia em mim, isso nunca ser√° null"

O problema:
- se for null, o erro acontece do mesmo jeito
- o TypeScript deixa de proteger
- o c√≥digo fica menos seguro

Forma usada no projeto (mais profissional):

const container = document.getElementById('root')

if (!container) {
  throw new Error('Root container missing')
}

createRoot(container).render(...)

Essa abordagem:
- √© mais expl√≠cita
- √© mais segura
- mostra maturidade t√©cnica
- facilita debug
- mant√©m o TypeScript trabalhando a favor

================================================================================
ANALOGIA SIMPLES
================================================================================

√â como tentar usar dinheiro sem saber se ele existe:

Errado:
comprarAlgo(dinheiro!)

Correto:
if (!dinheiro) {
  throw new Error('Sem saldo')
}

comprarAlgo(dinheiro)

================================================================================
RESUMO FINAL
================================================================================

- getElementById pode retornar null
- React n√£o aceita null no createRoot
- O if garante seguran√ßa
- O erro fica expl√≠cito
- Evita uso desnecess√°rio do !
- C√≥digo mais profissional e confi√°vel
================================================================================
-->









<!--
================================================================================
TAILWIND CSS ‚Äî PROCESSO COMPLETO DE INSTALA√á√ÉO (VERS√ÉO 3)
================================================================================

Este projeto utiliza Tailwind CSS na vers√£o 3 de forma consciente e intencional.

A vers√£o mais recente (v4) apresentou dificuldades de setup no ambiente com Vite,
principalmente relacionadas √† gera√ß√£o autom√°tica de arquivos de configura√ß√£o
e integra√ß√£o com o bundler.

Como o foco do projeto √© aprendizado, clareza e estabilidade,
a vers√£o 3 foi escolhida por ser:
- amplamente utilizada no mercado
- bem documentada
- est√°vel
- previs√≠vel

================================================================================
PASSO 1 ‚Äî REMO√á√ÉO DO TAILWIND (CASO J√Å EXISTA)
================================================================================

Antes de instalar o Tailwind v3, √© importante remover qualquer res√≠duo
de instala√ß√µes anteriores para evitar conflitos de vers√£o.

Comandos utilizados:

npm uninstall tailwindcss postcss autoprefixer

Ap√≥s isso, verificar e remover manualmente, se existirem:
- tailwind.config.js
- postcss.config.js

Isso garante um ambiente limpo para a nova instala√ß√£o.

================================================================================
PASSO 2 ‚Äî INSTALA√á√ÉO DO TAILWIND CSS v3
================================================================================

Instala√ß√£o expl√≠cita da vers√£o 3:

npm install -D tailwindcss@3 postcss autoprefixer

Ap√≥s a instala√ß√£o, gerar os arquivos de configura√ß√£o:

npx tailwindcss init -p

Esse comando cria automaticamente:
- tailwind.config.js
- postcss.config.js

================================================================================
PASSO 3 ‚Äî CONFIGURA√á√ÉO DO tailwind.config.js
================================================================================

Na vers√£o 3 do Tailwind, o arquivo de configura√ß√£o utiliza CommonJS.
Por isso, √© obrigat√≥rio usar module.exports.

Conte√∫do final do arquivo:

module.exports = {
  content: [
    "./index.html",
    "./src/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}

O campo "content" informa ao Tailwind onde procurar as classes
para gerar os estilos corretamente.

================================================================================
PASSO 4 ‚Äî CONFIGURA√á√ÉO DO CSS GLOBAL
================================================================================

No arquivo src/index.css, foram adicionadas as diretivas do Tailwind:

@tailwind base;
@tailwind components;
@tailwind utilities;

Esse arquivo √© importado no main.tsx, garantindo que os estilos
sejam aplicados globalmente na aplica√ß√£o.

================================================================================
PASSO 5 ‚Äî TESTE DE FUNCIONAMENTO
================================================================================

Para confirmar que o Tailwind est√° funcionando corretamente,
foi aplicado um layout simples no componente principal da aplica√ß√£o.

Exemplo utilizado no App.tsx:

function App() {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-900 text-white">
      <h1 className="text-3xl font-bold">
        Tailwind v3 funcionando
      </h1>
    </div>
  )
}

export default App

Se o fundo aparecer escuro, o texto branco e centralizado,
significa que o Tailwind est√° configurado corretamente.

================================================================================
CONCLUS√ÉO
================================================================================

A escolha pelo Tailwind CSS v3 n√£o representa atraso tecnol√≥gico,
mas sim uma decis√£o t√©cnica consciente para manter o foco no aprendizado,
evitar problemas de setup e garantir produtividade.

Vers√µes mais novas podem ser avaliadas futuramente,
quando a base do projeto estiver s√≥lida.

================================================================================
-->






















<!--
===========================================
ANOTA√á√ÉO IMPORTANTE ‚Äî TYPESCRIPT + RUNTIME
===========================================

Essa foi, de longe, a parte MAIS CONFUSA do in√≠cio do projeto.
Quase desisti aqui, ent√£o estou documentando com bastante detalhe
pra nunca mais passar por isso.

-------------------------------------------
1Ô∏è‚É£ O QUE SIGNIFICA "EXISTIR EM RUNTIME"?
-------------------------------------------

"Runtime" √© o MOMENTO em que o JavaScript est√° rodando de verdade,
ou seja:

- Quando o navegador abre a aplica√ß√£o
- Quando o c√≥digo j√° virou JavaScript
- Quando N√ÉO EXISTE mais TypeScript

üëâ Runtime = c√≥digo final executando no navegador.

-------------------------------------------
2Ô∏è‚É£ TYPESCRIPT N√ÉO EXISTE EM RUNTIME
-------------------------------------------

TypeScript √© s√≥ uma CAMADA DE DESENVOLVIMENTO.

Antes de rodar no navegador:
- O TypeScript √© COMPILADO
- Interfaces e types S√ÉO APAGADOS
- S√≥ sobra JavaScript

Exemplo:

interface Product {
  id: number
  title: string
}

‚¨áÔ∏è Depois da compila√ß√£o ‚¨áÔ∏è

(NADA)

Isso simplesmente N√ÉO EXISTE mais.

Ou seja:
‚ùå Interface N√ÉO vira vari√°vel
‚ùå Interface N√ÉO vira objeto
‚ùå Interface N√ÉO existe no JavaScript final

Ela s√≥ serve para:
- ajudar o editor
- evitar erros
- dar seguran√ßa de tipo

-------------------------------------------
3Ô∏è‚É£ O ERRO QUE ACONTECEU NO PROJETO
-------------------------------------------

Eu estava importando a interface assim:

import { Product } from '../types/Product'

Isso faz o bundler (Vite) pensar:

"Ok, ent√£o em runtime vai existir algo chamado Product"

MAS N√ÉO EXISTE.

Resultado:
- O Vite tenta encontrar Product no JavaScript
- N√£o acha nada
- A aplica√ß√£o quebra

-------------------------------------------
4Ô∏è‚É£ POR QUE ISSO ACONTECE EM PROJETOS MODERNOS?
-------------------------------------------

Meu projeto usa configura√ß√µes modernas, como:

- Vite
- TypeScript strict
- moduleResolution: "bundler"
- verbatimModuleSyntax: true

Essas configs s√£o MAIS R√çGIDAS de prop√≥sito.

Elas obrigam o dev a deixar claro:
- o que √© TYPE (s√≥ TS)
- o que √© VALUE (existe em runtime)

-------------------------------------------
5Ô∏è‚É£ A SOLU√á√ÉO CORRETA (IMPORTANTE)
-------------------------------------------

Sempre que importar APENAS tipos ou interfaces,
PRECISO usar:

import type { Product } from '../types/Product'

Isso diz claramente:

"Isso aqui √© S√ì PARA O TYPESCRIPT.
N√ÉO tente usar isso no JavaScript final."

Assim:
‚úÖ O TypeScript entende
‚úÖ O Vite n√£o tenta resolver em runtime
‚úÖ O erro some

-------------------------------------------
6Ô∏è‚É£ REGRA DE OURO PRA NUNCA MAIS ERRAR
-------------------------------------------

üß† REGRA SIMPLES:

- Interface / type ‚Üí import type
- Fun√ß√£o / componente / vari√°vel ‚Üí import normal

Exemplos:

‚úî import type { Product } from '../types/Product'
‚úî import { getAllProducts } from '../services/products'
‚úî import { useState, useEffect } from 'react'

-->




















<!--
=====================================================================
ANOTA√á√ÉO DEFINITIVA ‚Äî SERVICE DE PRODUTOS (API + ASYNC + TYPESCRIPT)
=====================================================================

Essa parte do projeto foi uma das mais dif√≠ceis de entender.
N√£o foi falta de capacidade: envolve conceitos FUNDAMENTAIS de
JavaScript ass√≠ncrono + TypeScript moderno + arquitetura de projeto.

Este arquivo N√ÉO √© um componente React.
Ele N√ÉO renderiza nada na tela.
Ele existe apenas para BUSCAR DADOS.

Arquivo:
src/services/products.ts

---------------------------------------------------------------------
1Ô∏è‚É£ O QUE √â ESSE ARQUIVO (IMPORTANTE)
---------------------------------------------------------------------

Esse arquivo √© um SERVICE.

Service √© uma camada respons√°vel APENAS por:
- buscar dados
- tratar erros
- garantir tipos

Ele N√ÉO:
- renderiza UI
- usa JSX
- conhece estado do React

React apenas CONSOME esse service.
Isso √© separa√ß√£o de responsabilidades (padr√£o profissional).

---------------------------------------------------------------------
2Ô∏è‚É£ POR QUE IMPORTAMOS A INTERFACE Product?
---------------------------------------------------------------------

import type { Product } from '../types/Product'

A interface Product √© um CONTRATO de dados.

Ela define exatamente como um produto deve ser:
- id
- title
- price
- description
- category
- image

Isso N√ÉO √© visual.
Isso N√ÉO √© componente.
Isso N√ÉO existe em runtime.

Serve para:
- evitar erro de digita√ß√£o
- evitar erro de tipo
- detectar problemas ANTES de rodar o app

Por isso usamos:
import type ‚Üí deixando claro que √© S√ì TypeScript.

---------------------------------------------------------------------
3Ô∏è‚É£ O QUE √â ESSA API_URL?
---------------------------------------------------------------------

const API_URL = 'https://fakestoreapi.com/products'

Isso √© o ENDERE√áO de onde os dados v√™m.

√â uma API (Application Programming Interface):
- um servidor externo
- que devolve dados
- no formato JSON

N√£o √© banco local.
N√£o √© mock.
√â uma API REST real.

---------------------------------------------------------------------
4Ô∏è‚É£ O QUE SIGNIFICA "async" E POR QUE USAR?
---------------------------------------------------------------------

export async function getAllProducts(): Promise<Product[]> {

Buscar dados da internet N√ÉO acontece na hora.
Pode:
- demorar
- falhar
- n√£o responder

O JavaScript roda em uma √∫nica fila.
Se ele travar esperando a internet, o app congela.

async significa:
"Essa fun√ß√£o come√ßa agora, mas termina depois.
N√£o trave o resto da aplica√ß√£o esperando."

Sem async:
‚ùå tela travaria
‚ùå app congelaria
‚ùå p√©ssima UX

Com async:
‚úÖ c√≥digo continua rodando
‚úÖ UI n√£o trava
‚úÖ experi√™ncia fluida

---------------------------------------------------------------------
5Ô∏è‚É£ O QUE √â Promise<Product[]>?
---------------------------------------------------------------------

Promise significa PROMESSA.

Essa fun√ß√£o N√ÉO retorna os produtos agora.
Ela retorna uma promessa dizendo:

"Quando tudo terminar, eu te entrego um array de Product."

Ou seja:
- agora ‚Üí Promise
- depois ‚Üí Product[]

Isso √© obrigat√≥rio em fun√ß√µes async,
porque os dados ainda N√ÉO EXISTEM no momento da chamada.

Projeto real N√ÉO funciona sem Promise.

---------------------------------------------------------------------
6Ô∏è‚É£ O QUE √â fetch?
---------------------------------------------------------------------

const response = await fetch(API_URL)

fetch √© a fun√ß√£o nativa do JavaScript para:
- fazer requisi√ß√µes HTTP
- buscar dados de APIs

Ele:
- vai at√© a URL
- pede os dados
- aguarda resposta

fetch SEMPRE retorna uma resposta se o servidor respondeu,
mesmo quando essa resposta √© um erro.

---------------------------------------------------------------------
7Ô∏è‚É£ O QUE √â await?
---------------------------------------------------------------------

await significa:
"Espere isso terminar antes de continuar."

Sem await:
- o c√≥digo continuaria sem dados
- tudo quebraria

await fetch(...) =
espera a API responder antes de seguir.

---------------------------------------------------------------------
8Ô∏è‚É£ O QUE √â response?
---------------------------------------------------------------------

response √© o OBJETO de resposta do servidor.

Ele cont√©m:
- status (200, 404, 500, etc)
- headers
- corpo da resposta (ainda n√£o convertido)

Importante:
response N√ÉO s√£o os dados ainda.
response SEMPRE existe se o servidor respondeu.

---------------------------------------------------------------------
9Ô∏è‚É£ O QUE S√ÉO OS C√ìDIGOS HTTP (200, 404, ETC)?
---------------------------------------------------------------------

Esses n√∫meros indicam o resultado da requisi√ß√£o:

200‚Äì299 ‚Üí sucesso
300‚Äì399 ‚Üí redirecionamento
400‚Äì499 ‚Üí erro do cliente
500‚Äì599 ‚Üí erro do servidor

Isso √© padr√£o da web, n√£o do React.

---------------------------------------------------------------------
üîü O QUE √â response.ok?
---------------------------------------------------------------------

response.ok √© um BOOLEAN (true ou false)
calculado automaticamente pelo navegador.

Funciona assim:
- status entre 200 e 299 ‚Üí ok = true
- qualquer outro status ‚Üí ok = false

Ou seja:
response.ok √© um RESUMO do status HTTP.

---------------------------------------------------------------------
1Ô∏è‚É£1Ô∏è‚É£ O QUE SIGNIFICA if (!response.ok)?
---------------------------------------------------------------------

O ! significa "N√ÉO".

if (!response.ok) significa:
"Se a resposta N√ÉO foi bem-sucedida"

Isso N√ÉO quer dizer que response n√£o existe.
Quer dizer:
- o servidor respondeu
- mas respondeu com erro (404, 500, etc)

Por isso N√ÉO usamos if (!response).

---------------------------------------------------------------------
1Ô∏è‚É£2Ô∏è‚É£ O QUE √â throw new Error?
---------------------------------------------------------------------

throw significa "lan√ßar um erro".

throw new Error('mensagem'):

- interrompe a execu√ß√£o da fun√ß√£o
- impede uso de dados inv√°lidos
- avisa quem chamou que algo deu errado

Isso N√ÉO quebra o app sozinho.
O erro pode (e deve) ser tratado depois.

√â a forma correta de tratar erro.

---------------------------------------------------------------------
1Ô∏è‚É£3Ô∏è‚É£ O QUE √â response.json()?
---------------------------------------------------------------------

A API devolve TEXTO em formato JSON.

response.json():
- converte esse texto
- em um objeto JavaScript

Essa convers√£o tamb√©m demora,
por isso usamos await.

---------------------------------------------------------------------
1Ô∏è‚É£4Ô∏è‚É£ O QUE √â 'as Product[]'?
---------------------------------------------------------------------

'as' √© do TypeScript, N√ÉO do JavaScript.

Ele significa:
"Confia em mim, isso tem esse formato."

as Product[] √© uma AFIRMA√á√ÉO de tipo.

Importante:
- N√ÉO valida dados
- N√ÉO altera runtime
- N√ÉO cria objeto

Serve apenas para ensinar o TypeScript.

---------------------------------------------------------------------
1Ô∏è‚É£5Ô∏è‚É£ POR QUE USAR 'as Product[]'?
---------------------------------------------------------------------

O TypeScript N√ÉO sabe o que vem da internet.
Ele n√£o confia automaticamente.

Sem 'as':
- o TS n√£o permite acessar propriedades
- gera erros de tipagem

Com 'as Product[]':
- o TS confia
- libera autocomplete
- evita erros futuros

---------------------------------------------------------------------
1Ô∏è‚É£6Ô∏è‚É£ POR QUE USAR PAR√äNTESES?
---------------------------------------------------------------------

(await response.json()) as Product[]

Significa:
1. espera o JSON
2. depois aplica o tipo

Os par√™nteses evitam ambiguidade de sintaxe.

---------------------------------------------------------------------
1Ô∏è‚É£7Ô∏è‚É£ CONCLUS√ÉO FINAL (IMPORTANTE)
---------------------------------------------------------------------

Esse arquivo N√ÉO √© React.
Ele √© uma camada de servi√ßo.

Ele existe para:
‚úî buscar dados
‚úî tratar erros
‚úî garantir tipos
‚úî manter o c√≥digo organizado

Entender isso foi dif√≠cil,
mas √© conhecimento FUNDAMENTAL
para projetos reais com TypeScript.
-->













<!--
===========================================================
ANOTA√á√ÉO COMPLETA ‚Äî COMPONENTE HOME (PASSO A PASSO)
===========================================================

Arquivo:
src/pages/Home.tsx

Esse arquivo √â um componente React.
Ele N√ÉO √© service.
Ele N√ÉO busca dados direto da API.
Ele √© respons√°vel APENAS por:

‚úî pedir os dados para a camada de service
‚úî controlar estados da interface (UI)
‚úî decidir O QUE aparece na tela e QUANDO

Se algo der errado aqui, N√ÉO √© problema de API,
√© problema de l√≥gica de estado ou renderiza√ß√£o.

-----------------------------------------------------------
1Ô∏è‚É£ IMPORTA√á√ïES ‚Äî O QUE CADA COISA FAZ DE VERDADE
-----------------------------------------------------------

import { useEffect, useState } from 'react'

- useState:
  serve para criar estados que controlam a interface.
  Quando um estado muda, o componente inteiro roda de novo.

- useEffect:
  serve para rodar c√≥digo em momentos espec√≠ficos do ciclo de vida.
  Aqui ele roda QUANDO o componente aparece na tela.

----------------------------------------

import type { Product } from '../types/Product'

- Product √© uma INTERFACE
- interface N√ÉO existe em runtime
- ela serve apenas para o TypeScript verificar tipos

Ela N√ÉO √© componente.
Ela N√ÉO renderiza nada.
Ela √© s√≥ um CONTRATO dizendo:
"um produto precisa ter essas propriedades".

----------------------------------------

import { getAllProducts } from '../services/products'

- Essa fun√ß√£o vem da camada de service.
- Ela √© respons√°vel por:
  ‚úî buscar dados
  ‚úî lidar com async
  ‚úî lidar com erro de API

O React N√ÉO sabe como os dados s√£o buscados.
Isso √© arquitetura correta.

-----------------------------------------------------------
2Ô∏è‚É£ DEFINI√á√ÉO DO COMPONENTE
-----------------------------------------------------------

export function Home() {

Esse √© um componente funcional React.
Tudo dentro dele √© executado:

‚úî no primeiro render
‚úî em todo re-render causado por mudan√ßa de estado

IMPORTANTE:
React n√£o executa linha por linha "uma vez".
Ele REEXECUTA o componente inteiro sempre que um estado muda.

-----------------------------------------------------------
3Ô∏è‚É£ ESTADOS ‚Äî ESSA √â A PARTE MAIS IMPORTANTE
-----------------------------------------------------------

const [products, setProducts] = useState<Product[]>([])

- products guarda os produtos vindos da API.
- come√ßa como array vazio porque:
  no primeiro render, ainda n√£o buscamos nada.

Isso N√ÉO significa erro.
Isso significa "ainda n√£o chegou".

----------------------------------------

const [loading, setLoading] = useState(true)

ESSA PARTE √â CR√çTICA.

loading N√ÉO √© algo autom√°tico.
loading N√ÉO vem da API.
loading N√ÉO vem do React.

loading √© uma DECIS√ÉO DE L√ìGICA.

true significa:
"enquanto isso for true, a interface deve mostrar carregamento".

N√£o existe nada m√°gico aqui.
√â s√≥ um boolean controlando o fluxo da UI.

----------------------------------------

const [error, setError] = useState<string | null>(null)

- error come√ßa como null (nenhum erro).
- se virar string, significa que houve erro.
- essa string ser√° exibida na tela.

-----------------------------------------------------------
4Ô∏è‚É£ useEffect ‚Äî QUANDO O C√ìDIGO RODA
-----------------------------------------------------------

useEffect(() => {

Esse useEffect roda:
‚úî uma √∫nica vez
‚úî quando o componente aparece na tela

Isso acontece porque o array de depend√™ncias √© [].

----------------------------------------

O useEffect N√ÉO pode ser async diretamente.
Por isso criamos uma fun√ß√£o async dentro dele.

-----------------------------------------------------------
5Ô∏è‚É£ FUN√á√ÉO loadProducts ‚Äî O FLUXO REAL
-----------------------------------------------------------

async function loadProducts() {

Essa fun√ß√£o existe para:
‚úî buscar os dados
‚úî tratar erro
‚úî controlar loading

Ela N√ÉO renderiza nada.
Ela s√≥ mexe em estado.

----------------------------------------
try {
----------------------------------------

const data = await getAllProducts()

- getAllProducts retorna uma Promise<Product[]>
- await faz o JavaScript esperar essa Promise resolver
- quando resolve, data vira Product[]

----------------------------------------

setProducts(data)

- isso atualiza o estado products
- setState causa RE-RENDER
- o componente Home vai rodar de novo

----------------------------------------
catch (err) {
----------------------------------------

IMPORTANTE:
err √© o ERRO que aconteceu.

Esse err:
- vem do throw new Error no service
- √© passado automaticamente pelo JavaScript

Mesmo que eu n√£o use err diretamente,
ele PRECISA existir para capturar o erro.

Aqui foi uma decis√£o consciente:
n√£o mostrar erro t√©cnico ao usu√°rio,
apenas uma mensagem gen√©rica.

----------------------------------------

setError('Erro ao carregar produtos')

- define que houve erro
- ativa renderiza√ß√£o condicional de erro

----------------------------------------
finally {
----------------------------------------

setLoading(false)

finally SEMPRE roda:
‚úî se deu certo
‚úî se deu erro
‚úî se algo inesperado aconteceu

Aqui √© onde dizemos:
"n√£o estou mais carregando".

-----------------------------------------------------------
6Ô∏è‚É£ CHAMADA DA FUN√á√ÉO
-----------------------------------------------------------

loadProducts()

Se eu n√£o chamar essa fun√ß√£o,
NADA acontece.

Declarar fun√ß√£o ‚â† executar fun√ß√£o.

-----------------------------------------------------------
7Ô∏è‚É£ RENDERIZA√á√ÉO CONDICIONAL ‚Äî COMO FUNCIONA DE VERDADE
-----------------------------------------------------------

IMPORTANTE:
React l√™ o c√≥digo de CIMA PARA BAIXO.
Quando encontra um return, ele PARA.

----------------------------------------
PRIORIDADE 1 ‚Äî LOADING
----------------------------------------

if (loading) {
  return <p>Carregando...</p>
}

Isso N√ÉO √© especial.
Isso N√ÉO √© React avan√ßado.
Isso √© JavaScript puro.

Enquanto loading = true:
- o componente retorna aqui
- nada abaixo √© executado
- produtos e erro N√ÉO existem na UI

----------------------------------------
PRIORIDADE 2 ‚Äî ERRO
----------------------------------------

if (error) {
  return <p>{error}</p>
}

Esse bloco s√≥ √© avaliado se loading for false.

Se error tiver valor:
- renderiza erro
- encerra o componente aqui

----------------------------------------
PRIORIDADE 3 ‚Äî SUCESSO
----------------------------------------

Se chegou aqui:
‚úî loading √© false
‚úî error √© null
‚úî products tem dados

Agora sim renderizamos os produtos.

-----------------------------------------------------------
8Ô∏è‚É£ RENDERIZA√á√ÉO DOS PRODUTOS
-----------------------------------------------------------

{products.map(product => (

- map percorre o array products
- product √© um Product (tipado)
- React exige uma key √∫nica

----------------------------------------

key={product.id}

- evita bugs de renderiza√ß√£o
- melhora performance
- √© obrigat√≥rio em listas

----------------------------------------

<img src={product.image} />

- imagem vem da API
- j√° validada e tipada

----------------------------------------

{product.title}
{product.price}

Nada disso seria poss√≠vel se:
- loading n√£o fosse controlado
- erro n√£o fosse tratado
- estados n√£o fossem bem definidos

-----------------------------------------------------------
9Ô∏è‚É£ RESUMO FINAL PRA EU DO FUTURO
-----------------------------------------------------------

Esse componente N√ÉO √© simples,
mas ele segue l√≥gica clara.

‚úî React N√ÉO busca dados
‚úî estados controlam tudo
‚úî loading √© s√≥ um boolean
‚úî erro √© s√≥ um estado
‚úî a ordem dos if define prioridade
‚úî return encerra renderiza√ß√£o

Se eu travar aqui de novo:
üëâ lembrar que React s√≥ reage a estado
üëâ lembrar que setState causa re-render
üëâ lembrar que n√£o existe m√°gica
üëâ lembrar que EU controlo o fluxo







-->

























<!--
=====================================================
ANOTA√á√ÉO COMPLETA ‚Äî BASE LAYOUT, CHILDREN E TIPAGEM
=====================================================

Essa anota√ß√£o existe para EU NO FUTURO entender:
- por que foi criado o BaseLayout
- por que usei children
- por que usei interface
- por que isso N√ÉO √© exagero
- e por que essa estrutura faz sentido em projeto real

Essa parte CONFUNDE MESMO no come√ßo.
N√£o √© √≥bvia.
Ent√£o a explica√ß√£o precisa ser completa.

-----------------------------------------------------
1Ô∏è‚É£ O QUE √â import type { ReactNode } from 'react'
-----------------------------------------------------

ReactNode √© APENAS um tipo do TypeScript.
Ele N√ÉO existe quando a aplica√ß√£o est√° rodando (runtime).

ReactNode representa:
- qualquer coisa que o React consegue renderizar
- JSX (<div>, <Component />)
- texto
- n√∫mero
- null
- arrays de JSX

Por isso uso:
import type { ReactNode } from 'react'

Isso diz claramente:
"isso aqui √© s√≥ tipagem, n√£o √© c√≥digo real".

Se eu importar sem 'type', o ESLint reclama,
porque ele tenta achar isso no JavaScript final,
mas ReactNode N√ÉO existe em runtime.

-----------------------------------------------------
2Ô∏è‚É£ O QUE √â children NO REACT
-----------------------------------------------------

children N√ÉO √© algo que eu criei.
children √© um comportamento padr√£o do React.

Tudo que eu coloco ENTRE as tags de um componente:

<BaseLayout>
  <Home />
</BaseLayout>

Automaticamente vira:

props.children = <Home />

Ou seja:
children √© simplesmente o CONTE√öDO INTERNO do componente.

-----------------------------------------------------
3Ô∏è‚É£ O QUE √â A INTERFACE BaseLayoutProps
-----------------------------------------------------

interface BaseLayoutProps {
  children: ReactNode
}

Essa interface √© um CONTRATO.

Ela diz:
"Se algu√©m usar o BaseLayout,
√© OBRIGAT√ìRIO passar children,
e esse children precisa ser algo renderiz√°vel."

A interface N√ÉO cria props.
A interface N√ÉO passa valores.
Ela s√≥ serve para o TypeScript validar.

-----------------------------------------------------
4Ô∏è‚É£ O QUE SIGNIFICA ESSA SINTAXE ESTRANHA
-----------------------------------------------------

export function BaseLayout({ children }: BaseLayoutProps)

Isso mistura DUAS coisas diferentes:

1) JavaScript ‚Üí desestrutura√ß√£o
2) TypeScript ‚Üí tipagem

-----------------------------------------------------
5Ô∏è‚É£ QUEBRANDO ESSA LINHA EM PARTES
-----------------------------------------------------

Parte 1 ‚Äî { children }

Isso √© desestrutura√ß√£o.
Significa:
"pegue a propriedade children de props".

√â o mesmo que:
props.children

Parte 2 ‚Äî : BaseLayoutProps

Isso √© TypeScript dizendo:
"as props desse componente precisam seguir essa interface".

Ou seja:
- precisa existir children
- children precisa ser ReactNode

Juntando tudo:
"Recebo props, valido com BaseLayoutProps e uso s√≥ o children".

-----------------------------------------------------
6Ô∏è‚É£ CHILDREN DA INTERFACE E CHILDREN DO COMPONENTE
-----------------------------------------------------

Eles N√ÉO s√£o diferentes.

S√£o a MESMA coisa vista em momentos diferentes:

- Interface ‚Üí define a regra
- Fun√ß√£o ‚Üí recebe o valor
- JSX ‚Üí renderiza

Tudo aponta para o mesmo children.

-----------------------------------------------------
7Ô∏è‚É£ POR QUE N√ÉO USAR props.children DIRETO?
-----------------------------------------------------

Eu poderia escrever assim:

export function BaseLayout(props: BaseLayoutProps) {
  return <main>{props.children}</main>
}

Isso FUNCIONA 100%.

A vers√£o com:
({ children }: BaseLayoutProps)

√©:
- mais limpa
- mais leg√≠vel
- mais comum no mercado

Por isso deixei assim.

-----------------------------------------------------
8Ô∏è‚É£ O QUE ACONTECE NO RETURN
-----------------------------------------------------

<main>
  {children}
</main>

Isso significa:
"Renderize aqui dentro tudo que veio de fora".

Se eu fizer:

<BaseLayout>
  <Home />
</BaseLayout>

O resultado final ser√°:

<header />
<main>
  <Home />
</main>
<footer />

O layout define a ESTRUTURA.
A p√°gina define o CONTE√öDO.

-----------------------------------------------------
9Ô∏è‚É£ O PROBLEMA DA SOLU√á√ÉO ‚ÄúF√ÅCIL‚Äù
-----------------------------------------------------

Existe uma forma mais simples de fazer isso,
que seria colocar tudo direto no App.tsx:

function App() {
  return (
    <>
      <Header />
      <main>
        <Home />
      </main>
      <Footer />
    </>
  )
}

Isso FUNCIONA.
N√£o tem erro t√©cnico nenhum.

Se o projeto fosse pequeno,
ou tivesse s√≥ uma p√°gina,
isso j√° resolveria.

-----------------------------------------------------
üîü ONDE A SOLU√á√ÉO F√ÅCIL COME√áA A DAR PROBLEMA
-----------------------------------------------------

O problema aparece quando o projeto cresce.

Hoje existe apenas a Home,
mas amanh√£ podem existir p√°ginas como:

- /produto/:id
- /login
- /checkout

Todas essas p√°ginas precisam:
- Header
- Footer
- SEO
- <main>

Se eu usar a solu√ß√£o f√°cil,
vou precisar copiar e colar essa estrutura
ou deixar o App.tsx gigante e confuso.

Isso gera:
- c√≥digo duplicado
- manuten√ß√£o dif√≠cil
- mais chance de erro no futuro

-----------------------------------------------------
1Ô∏è‚É£1Ô∏è‚É£ O QUE O BaseLayout RESOLVE DE VERDADE
-----------------------------------------------------

O BaseLayout resolve problemas REAIS de arquitetura.

Com BaseLayout:

<BaseLayout>
  <Home />
</BaseLayout>

Depois:

<BaseLayout>
  <ProductPage />
</BaseLayout>

Depois:

<BaseLayout>
  <Checkout />
</BaseLayout>

‚û°Ô∏è A estrutura √© sempre a mesma
‚û°Ô∏è S√≥ o conte√∫do muda
‚û°Ô∏è Nenhuma repeti√ß√£o de Header, Main e Footer

-----------------------------------------------------
1Ô∏è‚É£2Ô∏è‚É£ CONCLUS√ÉO PRA EU NO FUTURO
-----------------------------------------------------

A solu√ß√£o f√°cil resolve o AGORA.
O BaseLayout resolve o FUTURO.

Ele existe para:
- reaproveitar estrutura
- manter o c√≥digo organizado
- facilitar manuten√ß√£o
- garantir sem√¢ntica e SEO
- permitir crescimento sem bagun√ßa

Por isso faz sentido usar:
- children
- interface
- ReactNode
- import type

Mesmo parecendo mais c√≥digo no come√ßo.

-----------------------------------------------------
1Ô∏è‚É£3Ô∏è‚É£ REGRA DE OURO PRA N√ÉO ESQUECER
-----------------------------------------------------

- children = conte√∫do interno
- ReactNode = tudo que pode ser renderizado
- interface = contrato
- import type = s√≥ tipagem
- BaseLayout = estrutura fixa
- p√°ginas = conte√∫do vari√°vel

Se eu estiver confuso no futuro,
lembra disso:

"Layout envolve p√°ginas,
p√°ginas N√ÉO envolvem layout."
-->


































<!--
===========================================================
ANOTA√á√ÉO COMPLETA ‚Äî useParams, ROTAS DIN√ÇMICAS E ID NA URL
===========================================================

Essa anota√ß√£o existe para EU NO FUTURO entender:
- o que √© useParams
- por que ele existe
- como ele funciona
- por que usamos {} na const
- como o id aparece sem buscar dados
- e como isso se conecta com API depois

Nada aqui √© m√°gico.
Tudo √© fluxo.

-----------------------------------------------------------
1Ô∏è‚É£ O QUE √â useParams
-----------------------------------------------------------

useParams √© um HOOK do react-router-dom.

Ele serve para:
üëâ LER par√¢metros din√¢micos da URL

Par√¢metro din√¢mico = parte vari√°vel da rota.

Exemplo de rota:

<Route path="/produto/:id" element={<Product />} />

Aqui:
- :id √© um par√¢metro
- o valor real vem da URL

Se a URL for:
http://localhost:5173/produto/3

Ent√£o:
id = "3"

Quem faz essa leitura automaticamente √© o useParams.

-----------------------------------------------------------
2Ô∏è‚É£ O QUE useParams RETORNA
-----------------------------------------------------------

useParams SEMPRE retorna um OBJETO.

Exemplo real:

useParams()

retorna algo assim:

{
  id: "3"
}

üìå Importante:
- Tudo vem como STRING
- Mesmo se o ID for um n√∫mero

-----------------------------------------------------------
3Ô∏è‚É£ POR QUE USAMOS { id } = useParams()
-----------------------------------------------------------

Essa linha junta dois conceitos:

const { id } = useParams()

Vamos separar.

Primeiro, sem desestrutura√ß√£o:

const params = useParams()
const id = params.id

Agora, com desestrutura√ß√£o (forma curta):

const { id } = useParams()

Isso √© JavaScript puro.
N√£o √© React.
N√£o √© TypeScript.

Significa:
üëâ "pegue a propriedade id de dentro do objeto retornado"

-----------------------------------------------------------
4Ô∏è‚É£ POR QUE USAMOS CONST
-----------------------------------------------------------

Usamos const porque:
- o valor vem da URL
- n√£o muda durante o render
- √© s√≥ leitura

N√£o faz sentido usar let aqui.

-----------------------------------------------------------
5Ô∏è‚É£ DE ONDE VEM ESSE ID?
-----------------------------------------------------------

O id N√ÉO vem de um objeto produto.
O id N√ÉO vem da API.
O id N√ÉO vem do Home.

Ele vem EXCLUSIVAMENTE da URL.

Fluxo real:

URL ‚Üí React Router ‚Üí useParams ‚Üí id

Exemplo:

/produto/3
‚Üì
useParams()
‚Üì
{ id: "3" }

-----------------------------------------------------------
6Ô∏è‚É£ POR QUE N√ÉO USAMOS product.id AQUI?
-----------------------------------------------------------

Na Home:
- voc√™ j√° tem os produtos
- voc√™ j√° tem os dados
- voc√™ faz map(product)

Na p√°gina de Produto:
- voc√™ N√ÉO tem dados ainda
- voc√™ s√≥ sabe QUAL produto quer
- voc√™ s√≥ tem o ID

Ou seja:
product ainda N√ÉO existe.

Primeiro:
- pega o ID da URL

Depois (pr√≥ximo passo):
- usa o ID para buscar o produto na API

-----------------------------------------------------------
7Ô∏è‚É£ EXEMPLO SIMPLES DE USO ATUAL
-----------------------------------------------------------

P√°gina de Produto simples:

import { useParams } from 'react-router-dom'

export function Product() {
  const { id } = useParams()

  return (
    <div>
      <h1>P√°gina de Produto</h1>
      <p>ID do produto: {id}</p>
    </div>
  )
}

Isso N√ÉO busca dados.
Isso s√≥ prova que a rota din√¢mica funciona.

-----------------------------------------------------------
8Ô∏è‚É£ EXEMPLO COM MAIS DE UM PAR√ÇMETRO
-----------------------------------------------------------

Rota:

<Route path="/categoria/:categoriaId/produto/:id" element={<Product />} />

URL:
http://localhost:5173/categoria/10/produto/3

useParams retorna:

{
  categoriaId: "10",
  id: "3"
}

Uso:

const { categoriaId, id } = useParams()

-----------------------------------------------------------
9Ô∏è‚É£ EXEMPLO COM OUTRA IDEIA (USU√ÅRIO)
-----------------------------------------------------------

Rota:

<Route path="/usuario/:username" element={<User />} />

URL:
http://localhost:5173/usuario/mikael

useParams retorna:

{
  username: "mikael"
}

Uso:

const { username } = useParams()

-----------------------------------------------------------
üîü EXEMPLO SEM DESESTRUTURA√á√ÉO (FORMA LONGA)
-----------------------------------------------------------

Voc√™ tamb√©m pode fazer assim:

const params = useParams()

return (
  <p>ID: {params.id}</p>
)

Funciona igual.
S√≥ √© menos usado.

-----------------------------------------------------------
1Ô∏è‚É£1Ô∏è‚É£ O QUE useParams N√ÉO FAZ
-----------------------------------------------------------

useParams N√ÉO:
- busca dados
- chama API
- valida ID
- converte string em n√∫mero

Ele APENAS l√™ a URL.

-----------------------------------------------------------
1Ô∏è‚É£2Ô∏è‚É£ CONEX√ÉO COM API (PR√ìXIMO PASSO)
-----------------------------------------------------------

Fluxo completo profissional:

1Ô∏è‚É£ URL cont√©m o ID
2Ô∏è‚É£ useParams l√™ o ID
3Ô∏è‚É£ useEffect usa o ID
4Ô∏è‚É£ API √© chamada com esse ID
5Ô∏è‚É£ product √© carregado
6Ô∏è‚É£ p√°gina renderiza dados reais

Exemplo futuro:

const { id } = useParams()

useEffect(() => {
  fetch(`/api/products/${id}`)
}, [id])

-----------------------------------------------------------
1Ô∏è‚É£3Ô∏è‚É£ REGRA DE OURO PRA N√ÉO CONFUNDIR
-----------------------------------------------------------

- useParams ‚Üí l√™ URL
- id ‚Üí vem da rota
- product ‚Üí vem da API
- Home ‚Üí lista
- Product ‚Üí detalhe

Se eu s√≥ tenho o ID:
üëâ ainda n√£o tenho dados

-----------------------------------------------------------
1Ô∏è‚É£4Ô∏è‚É£ FRASE PRA EU LEMBRAR NO FUTURO
-----------------------------------------------------------

"A URL me diz QUEM eu quero.
A API me diz O QUE ele √©."

===========================================================
FIM DA ANOTA√á√ÉO
===========================================================
-->

































<!--

=====================================================
ANOTA√á√ÉO COMPLETA ‚Äî P√ÅGINA DE PRODUTO (Product.tsx)
=====================================================

Essa anota√ß√£o documenta TODO o racioc√≠nio por tr√°s
da p√°gina de detalhes do produto.

Ela existe para:
- eu entender TypeScript no React
- n√£o copiar c√≥digo sem entender
- lembrar por que cada coisa existe
- evitar erros comuns no futuro

-----------------------------------------------------
1Ô∏è‚É£ O QUE ESSE COMPONENTE FAZ
-----------------------------------------------------

Esse componente representa a p√°gina:

/produto/:id

Exemplo de URL:
http://localhost:5173/produto/3

Ele:
- l√™ o ID da URL
- busca o produto pelo ID
- controla loading e erro
- exibe os dados do produto

-----------------------------------------------------
2Ô∏è‚É£ IMPORTS ‚Äî O QUE CADA UM FAZ
-----------------------------------------------------

import { useEffect, useState } from 'react'

useState:
- cria estados (product, loading, error)

useEffect:
- executa c√≥digo quando algo muda
- aqui usamos para buscar o produto quando o ID muda


import { useParams } from 'react-router-dom'

useParams:
- l√™ par√¢metros din√¢micos da URL
- no nosso caso: o :id da rota


import type { Product as ProductType } from '../types/Product'

Aqui acontece algo MUITO importante:

- Existe uma interface chamada Product
- Ela descreve o formato de um produto
- O nome Product entra em conflito com o componente Product

Ent√£o fazemos:
Product ‚Üí ProductType

‚ö†Ô∏è ProductType N√ÉO √© outro tipo.
√â O MESMO Product, s√≥ com outro nome.

Isso se chama ALIAS DE TIPO.

Usamos `import type` porque:
- isso √© s√≥ TypeScript
- n√£o existe em runtime
- evita erro do ESLint


import { getProdutoPorId } from '../services/products'

Fun√ß√£o respons√°vel por:
- buscar UM produto na API
- retornar um Product tipado

-----------------------------------------------------
3Ô∏è‚É£ ESTRUTURA DO COMPONENTE
-----------------------------------------------------

export default function Product() {

Esse √© o componente da p√°gina de produto.

-----------------------------------------------------
4Ô∏è‚É£ useParams + DESESTRUTURA√á√ÉO
-----------------------------------------------------

const { id } = useParams<{ id: string }>()

Vamos quebrar isso:

useParams() retorna um OBJETO com os par√¢metros da rota.

Exemplo:
URL: /produto/3

Retorno:
{ id: "3" }

A DESESTRUTURA√á√ÉO:
{ id }

Significa:
"pegue a propriedade id desse objeto"

O <{ id: string }> √© um GENERIC.

GENERIC = "eu quero definir o tipo manualmente"

Aqui estamos dizendo:
"O objeto retornado ter√° uma propriedade id do tipo string"

‚ö†Ô∏è Mesmo assim, o TypeScript considera:
id: string | undefined

Porque:
- a rota pode estar errada
- o usu√°rio pode acessar /produto/ sem id

-----------------------------------------------------
5Ô∏è‚É£ ESTADOS DO COMPONENTE
-----------------------------------------------------

const [product, setProduct] = useState<ProductType | null>(null)

Aqui temos 3 conceitos importantes:

1) GENERIC:
<ProductType | null>

Estamos dizendo:
"Esse estado pode ser:
- um produto (ProductType)
- OU null"

Isso √© um UNION TYPE.

Union Type = tipo A OU tipo B


2) Por que null?
Porque:
- antes da API responder
- n√£o existe produto ainda


const [loading, setLoading] = useState(true)

Controla se a busca ainda est√° acontecendo.


const [error, setError] = useState<string | null>(null)

Guarda mensagens de erro, se algo der errado.

-----------------------------------------------------
6Ô∏è‚É£ useEffect ‚Äî FLUXO COMPLETO
-----------------------------------------------------

useEffect(() => {
}, [id])

Esse efeito roda:
- quando o componente monta
- sempre que o ID da URL mudar

-----------------------------------------------------
7Ô∏è‚É£ VALIDA√á√ÉO DO ID
-----------------------------------------------------

if (!id) {
  setError('ID do produto n√£o encontrado')
  setLoading(false)
  return
}

Isso significa:

- Se o ID N√ÉO existir
- Evita chamar a API
- Evita erro de tipagem
- Mostra erro pro usu√°rio
- Para o loading
- Sai da fun√ß√£o (return)

Esse return √© FUNDAMENTAL.
Sem ele, o c√≥digo continuaria executando.

-----------------------------------------------------
8Ô∏è‚É£ AFIRMA√á√ÉO DE TIPO (TYPE NARROWING)
-----------------------------------------------------

const productId: string = id

Aqui acontece algo importante:

Antes:
id ‚Üí string | undefined

Depois dessa valida√ß√£o (!id):
o TypeScript SABE que id √© string.

Essa linha afirma isso explicitamente.

Isso se chama:
TYPE NARROWING (afunilamento de tipo)

-----------------------------------------------------
9Ô∏è‚É£ FUN√á√ÉO ASS√çNCRONA DE BUSCA
-----------------------------------------------------

async function loadProduct() {

Criamos uma fun√ß√£o async dentro do useEffect
porque:
- useEffect N√ÉO pode ser async diretamente

-----------------------------------------------------
üîÅ TRY / CATCH / FINALLY
-----------------------------------------------------

try {
  const data = await getProdutoPorId(productId)
  setProduct(data)
}

Aqui:
- chamamos o service
- esperamos a resposta
- data √© do tipo ProductType
- salvamos no estado product


catch {
  setError('Erro ao carregar produto')
}

Se algo falhar:
- exibimos erro


finally {
  setLoading(false)
}

Sempre executa:
- com sucesso ou erro
- encerra o loading

-----------------------------------------------------
üîÑ EXECU√á√ÉO DA FUN√á√ÉO
-----------------------------------------------------

loadProduct()

Chama a fun√ß√£o definida acima.

-----------------------------------------------------
10Ô∏è‚É£ RENDERIZA√á√ÉO CONDICIONAL
-----------------------------------------------------

if (loading) {
  return <p>Carregando...</p>
}

Enquanto carrega:
- n√£o acessa product
- evita erro
- mostra feedback


if (error) {
  return <p>{error}</p>
}

Se deu erro:
- mostra mensagem clara


if (!product) {
  return <p>Produto n√£o encontrado</p>
}

Prote√ß√£o extra:
- garante que product existe

-----------------------------------------------------
11Ô∏è‚É£ RENDER FINAL DO PRODUTO
-----------------------------------------------------

Quando tudo deu certo:

- product existe
- loading √© false
- error √© null

Podemos acessar com seguran√ßa:

product.title
product.image
product.description
product.price

exemplo feito no componente:
return (
    <div className="p-6 text-white">
      <h1 className="text-2xl font-bold mb-4">{product.title}</h1>

      <img
        src={product.image}
        alt={product.title}
        className="h-64 object-contain mb-4"
      />

      <p className="mb-4">{product.description}</p>

      <p className="text-xl font-semibold">
        R$ {product.price}
      </p>
    </div>
  )

-----------------------------------------------------
12Ô∏è‚É£ ERROS QUE ACONTECERAM (E POR QU√ä)
-----------------------------------------------------

‚ùå Erro:
Argument of type 'string | undefined'...

Motivo:
- useParams pode retornar undefined

Solu√ß√£o:
- valida√ß√£o do id
- type narrowing


‚ùå Erro:
product.description n√£o existe

Motivo:
- product podia ser null

Solu√ß√£o:
- renderiza√ß√£o condicional
- union type bem definido

-----------------------------------------------------
13Ô∏è‚É£ CONCEITOS APRENDIDOS AQUI
-----------------------------------------------------

‚úîÔ∏è useParams
‚úîÔ∏è Generics
‚úîÔ∏è Union Types
‚úîÔ∏è Type Narrowing
‚úîÔ∏è Alias de tipo
‚úîÔ∏è Tipagem de API
‚úîÔ∏è Fluxo ass√≠ncrono correto
‚úîÔ∏è Padr√£o profissional de p√°gina

-----------------------------------------------------
14Ô∏è‚É£ REGRA DE OURO PRA LEMBRAR
-----------------------------------------------------

- URL fornece dados ‚Üí useParams
- API pode falhar ‚Üí error
- API demora ‚Üí loading
- Estado come√ßa vazio ‚Üí null
- TypeScript protege ‚Üí escute ele

Se o TS reclama, N√ÉO IGNORE.
Ele est√° te salvando de bugs.

=====================================================
FIM DA ANOTA√á√ÉO
=====================================================


-->















<!--
====================================================================
ANOTA√á√ÉO COMPLETA ‚Äî FEATURE BASE DE DADOS LOCAL + UI/UX FIRST
====================================================================

Essa feature mudou COMPLETAMENTE a base do projeto.

Sa√≠mos de:
- API externa (FakeStore)
- dados em ingl√™s
- produtos aleat√≥rios
- l√≥gica antes do visual

Para:
- Banco de dados local (JSON)
- produtos em PT-BR
- categorias reais
- foco em UI/UX primeiro
- arquitetura clara e profissional

====================================================================
1Ô∏è‚É£ POR QUE CRIAMOS UM BANCO DE DADOS LOCAL (JSON)
====================================================================

Decis√£o de arquitetura:

‚ùå API externa:
- dados fora do meu controle
- t√≠tulos e descri√ß√µes em ingl√™s
- produtos sem contexto
- depend√™ncia externa

‚úÖ JSON local:
- total controle dos dados
- produtos realistas
- f√°cil de trocar no futuro
- qualquer pessoa pode usar o projeto
  ‚Üí basta trocar o JSON

O JSON N√ÉO √© l√≥gica.
Ele √© apenas DADOS.

====================================================================
2Ô∏è‚É£ ESTRUTURA DO JSON (VIS√ÉO GERAL)
====================================================================

O JSON segue esta ideia:

BancoDeProdutos
 ‚îî‚îÄ categorias[]
     ‚îî‚îÄ categoria
         ‚îú‚îÄ slug
         ‚îú‚îÄ nome
         ‚îî‚îÄ produtos[]
             ‚îî‚îÄ produto
                 ‚îú‚îÄ id
                 ‚îú‚îÄ titulo
                 ‚îú‚îÄ descricao
                 ‚îú‚îÄ preco
                 ‚îú‚îÄ preco_desconto
                 ‚îú‚îÄ imagens[]
                 ‚îî‚îÄ categoria

O JSON N√ÉO valida nada.
Quem valida √© o TypeScript.

====================================================================
3Ô∏è‚É£ INTERFACES (TYPESCRIPT) ‚Äî O MOLDE DOS DADOS
====================================================================

IMPORTANTE:
Interface ‚â† dados reais  
Interface = REGRA / MOLDE / CONTRATO

Ela diz:
"Se voc√™ quiser usar esse dado, ele PRECISA ter essa forma."

-----------------------------------------------------
üìÑ Product.ts
-----------------------------------------------------

export interface Product {
  id: number
  titulo: string
  descricao: string
  preco: number
  preco_desconto: number | null
  imagens: string[]
  categoria: string
}

Aqui definimos:
- o que √© um produto
- quais campos ele tem
- quais s√£o obrigat√≥rios
- quais podem ser null

O `| null` significa:
‚Üí Union Type
‚Üí pode ser number OU null

-----------------------------------------------------
üìÑ Categoria.ts
-----------------------------------------------------

import type { Product } from './Product'

export interface Categoria {
  slug: string
  nome: string
  produtos: Product[]
}

Aqui acontece algo importante:

- Categoria N√ÉO inventa produto
- Ela IMPORTA o modelo Product
- produtos √© um ARRAY de Product

Ou seja:
Cada item dentro de produtos PRECISA seguir
o formato definido em Product.ts

-----------------------------------------------------
üìÑ BancoDeProdutos.ts
-----------------------------------------------------

import type { Categoria } from './Categoria'

export interface BancoDeProdutos {
  categorias: Categoria[]
}

Isso representa o JSON inteiro.

N√£o √© um banco real.
√â apenas o MOLDE do banco.

====================================================================
4Ô∏è‚É£ SERVICES ‚Äî A CAMADA DE ACESSO AOS DADOS
====================================================================

O service serve para:
- isolar l√≥gica
- evitar acessar o JSON direto nas p√°ginas
- facilitar troca futura (JSON ‚Üí API)

-----------------------------------------------------
üìÑ services/products.ts
-----------------------------------------------------

import produtosJson from '../data/produtos.json'
import type { BancoDeProdutos } from '../types/BancoDeProdutos'
import type { Categoria } from '../types/Categoria'
import type { Product } from '../types/Product'

const bancoDeProdutos = produtosJson as BancoDeProdutos

Aqui acontece uma COISA MUITO IMPORTANTE:

- produtosJson vem do JSON (JavaScript puro)
- TypeScript N√ÉO sabe o formato disso
- usamos `as BancoDeProdutos` para dizer:

"CONFIA, esse JSON segue esse modelo"

Isso √©:
‚Üí Type Assertion (afirma√ß√£o de tipo)

-----------------------------------------------------
üîπ getCategorias
-----------------------------------------------------

export function getCategorias(): Categoria[] {
  return bancoDeProdutos.categorias
}

Essa fun√ß√£o:
- retorna TODAS as categorias
- j√° tipadas corretamente
- sem l√≥gica complexa

√â usada na Home.

-----------------------------------------------------
üîπ getProdutosPorCategoria
-----------------------------------------------------

export function getProdutosPorCategoria(slug: string): Product[] {
  const categoria = bancoDeProdutos.categorias.find(
    (cat) => cat.slug === slug
  )

  return categoria ? categoria.produtos : []
}

Aqui acontece:

1) Recebo um slug (string)
2) Procuro uma categoria com esse slug
3) Se existir:
   ‚Üí retorno os produtos dela
4) Se n√£o existir:
   ‚Üí retorno array vazio

Por que array vazio?
Porque evita erro no map().

-----------------------------------------------------
üîπ getProdutoPorId
-----------------------------------------------------

export function getProdutoPorId(id: number): Product | undefined {
  for (const categoria of bancoDeProdutos.categorias) {
    const produto = categoria.produtos.find(
      (produto) => produto.id === id
    )

    if (produto) return produto
  }

  return undefined
}

Essa fun√ß√£o:
- percorre TODAS as categorias
- procura o produto pelo id
- retorna o produto se achar
- retorna undefined se n√£o achar

Isso simula um banco real.

====================================================================
5Ô∏è‚É£ ROTAS ‚Äî App.tsx
====================================================================

<BrowserRouter>
  <BaseLayout>
    <Routes>
      <Route path="/" element={<Home />} />
      <Route path="/produto/:id" element={<Product />} />
      <Route path="/carrinho" element={<Cart />} />
    </Routes>
  </BaseLayout>
</BrowserRouter>

Importante:

- BaseLayout envolve tudo
- Header e Footer s√£o fixos
- apenas o conte√∫do central muda

A rota /produto/:id √© din√¢mica.
Exemplo:
- /produto/3
- /produto/10

====================================================================
6Ô∏è‚É£ HOME ‚Äî EXIBINDO CATEGORIAS E PRODUTOS
====================================================================

Na Home:

- chamamos getCategorias()
- fazemos map nas categorias
- dentro de cada categoria:
  - exibimos os produtos
  - usamos Link para navegar

Exemplo:

<Link to={`/produto/${produto.id}`}>

Isso conecta Home ‚Üí Product.

====================================================================
7Ô∏è‚É£ PRODUCT ‚Äî P√ÅGINA DE PRODUTO
====================================================================

A p√°gina Product √© uma p√°gina DIN√ÇMICA.

-----------------------------------------------------
üîπ useParams
-----------------------------------------------------

const { id } = useParams<{ id: string }>()

Isso significa:
- a URL tem /produto/:id
- id SEMPRE vem como string
- mesmo sendo n√∫mero no JSON

-----------------------------------------------------
üîπ Convers√£o de ID
-----------------------------------------------------

const productId = Number(id)

Por qu√™?
Porque no JSON o id √© number.

Depois validamos:
- se √© NaN
- se existe produto

-----------------------------------------------------
üîπ Estados
-----------------------------------------------------

const [product, setProduct] = useState<Product | null>(null)
const [loading, setLoading] = useState(true)
const [error, setError] = useState<string | null>(null)

Isso controla:
- carregamento
- erro
- produto encontrado

-----------------------------------------------------
üîπ L√≥gica do useEffect
-----------------------------------------------------

1) Verifica se existe id
2) Converte id para number
3) Busca produto no service
4) Se n√£o existir ‚Üí erro
5) Se existir ‚Üí seta produto
6) Finaliza loading

-----------------------------------------------------
üîπ Render condicional
-----------------------------------------------------

if (loading) ‚Üí mostra loading
if (error) ‚Üí mostra erro
if (!product) ‚Üí produto n√£o encontrado

Isso evita:
- acessar dados inexistentes
- erros de runtime

====================================================================
8Ô∏è‚É£ UI/UX ‚Äî DECIS√ÉO DE DESIGN
====================================================================

Prioridade agora:
- layout profissional
- visual antes da l√≥gica pesada
- experi√™ncia clara

Decis√µes:
- cards com imagem centralizada
- pre√ßo com desconto destacado
- hover suave
- grid responsivo
- hero introdut√≥rio
- categorias separadas

====================================================================
9Ô∏è‚É£ REGRA DE OURO DESSA FEATURE
====================================================================

- JSON = dados
- Interfaces = regras
- Service = l√≥gica
- Pages = renderiza√ß√£o
- Router = navega√ß√£o
- UI vem ANTES da l√≥gica pesada

====================================================================
üîö CONCLUS√ÉO
====================================================================

Essa feature:
- organizou o projeto
- deixou escal√°vel
- deixou profissional
- facilitou aprendizado
- preparou o terreno para:
  ‚Üí carrinho
  ‚Üí categorias
  ‚Üí recomendados
  ‚Üí filtros
  ‚Üí backend real no futuro

Se no futuro eu estiver perdido, lembrar:
"Primeiro estrutura, depois l√≥gica, depois refinamento."

-->
