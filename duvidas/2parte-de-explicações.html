<!--
essas anota√ß√µes deram inicio em: 18/01/2025-->






<!--
/* =====================================================================
   FEATURE: LIGHT / DARK MODE ‚Äî TUTORIAL COMPLETO DO ZERO (ANOTA√á√ïES)

   OBJETIVO:
   Implementar um sistema de tema (light / dark) reutiliz√°vel,
   simples de manter, escal√°vel e que funcione em QUALQUER projeto React.

   IMPORTANTE:
   - Isso N√ÉO √© s√≥ trocar cor.
   - Isso √© controle de ESTADO + CSS + DOM + arquitetura.
   - Se voc√™ entender isso, voc√™ consegue fazer tema em qualquer app.

===================================================================== */


/* =====================================================================
   1Ô∏è‚É£ CONCEITO FUNDAMENTAL (ANTES DE CODAR)
===================================================================== */

/*
  ‚ùì Por que tema (light/dark) N√ÉO deve ser controlado s√≥ com Tailwind classes?

  Porque:
  - Voc√™ teria que repetir classes em TODOS os componentes
  - Ficaria imposs√≠vel manter
  - O projeto ficaria fr√°gil e nada reutiliz√°vel

  ‚úî Solu√ß√£o profissional:
  ‚Üí Centralizar cores em CSS VARIABLES
  ‚Üí Controlar o tema com UMA classe no DOM (body ou html)
*/


/*
  ‚ùì O que √© uma CSS Variable?

  Exemplo:
  --bg: 255 255 255;

  Isso √© uma vari√°vel global de cor.
  Ela pode ser reutilizada em qualquer lugar do projeto.

  A grande sacada:
  ‚Üí Voc√™ muda o VALOR da vari√°vel
  ‚Üí Todo o site muda automaticamente
*/


/*
  ‚ùì Onde o tema deve viver?

  REGRA MENTAL:
  - Tema √© estado GLOBAL
  - Estado global N√ÉO pertence a componentes pequenos

  ‚úî Lugar correto:
  - App.tsx OU BaseLayout (onde o site inteiro √© montado)
*/


/* =====================================================================
   2Ô∏è‚É£ ESTRUTURA NECESS√ÅRIA PRA FUNCIONAR
===================================================================== */

/*
  Pra essa feature funcionar, o projeto PRECISA ter:

  ‚úÖ React (√≥bvio)
  ‚úÖ Tailwind configurado
  ‚úÖ index.css global
  ‚úÖ Um componente pai (App ou Layout)
  ‚úÖ Um bot√£o que altera o estado

  Sem isso, a l√≥gica quebra.
*/


/* =====================================================================
   3Ô∏è‚É£ CSS ‚Äî ONDE TUDO REALMENTE ACONTECE
===================================================================== */

/*
  üìç Arquivo: src/index.css

  Aqui N√ÉO tem React.
  Aqui N√ÉO tem JavaScript.

  Aqui √© onde definimos:
  - As cores base do projeto
  - O que √© light
  - O que √© dark
*/

:root {
  /*
    LIGHT THEME
    Esse √© o tema padr√£o do site.
    Sempre que N√ÉO existir a classe .dark no body,
    esses valores ser√£o usados.
  */

  --bg: 239 246 255;
  --bg-secondary: 226 232 240;
  --surface: 248 250 252;

  --text: 15 23 42;
  --text-muted: 71 85 105;

  --primary: 37 99 235;
  --primary-hover: 29 78 216;
}

.dark {
  /*
    DARK THEME
    Quando a classe .dark existir no body,
    ESSAS cores sobrescrevem as do :root
  */

  --bg: 2 6 23;
  --bg-secondary: 3 7 30;
  --surface: 15 23 42;

  --text: 226 232 240;
  --text-muted: 148 163 184;

  --primary: 96 165 250;
  --primary-hover: 59 130 246;
}


/*
  Aplica√ß√£o global
  Aqui conectamos as vari√°veis ao site real
*/

body {
  background-color: rgb(var(--bg));
  color: rgb(var(--text));
  transition: background-color 0.3s ease, color 0.3s ease;
}


/* =====================================================================
   4Ô∏è‚É£ L√ìGICA DO REACT ‚Äî ONDE O C√âREBRO FICA
===================================================================== */

/*
  üìç Arquivo: App.tsx OU BaseLayout.tsx

  Aqui √© onde voc√™ controla:
  - Qual tema est√° ativo
  - Quando trocar
  - Quem pode trocar
*/


/*
  PASSO 1 ‚Äî Definir o tipo do tema

  Isso √© TypeScript puro.
  Estamos dizendo:
  "S√≥ existem DOIS temas poss√≠veis"
*/

type Theme = 'light' | 'dark'


/*
  PASSO 2 ‚Äî Criar o estado

  useState guarda:
  - O tema ATUAL do site
*/

const [theme, setTheme] = useState<Theme>('light')


/*
  PASSO 3 ‚Äî Efeito colateral (useEffect)

  ‚ùó Isso √© MUITO importante.

  Toda vez que o `theme` muda,
  precisamos refletir isso NO DOM (body).

  React N√ÉO controla o body diretamente.
  Ent√£o fazemos isso manualmente.
*/

useEffect(() => {
  /*
    Se o tema for dark:
    ‚Üí adiciona a classe 'dark' no body
  */
  if (theme === 'dark') {
    document.body.classList.add('dark')
  } else {
    /*
      Se for light:
      ‚Üí remove a classe 'dark'
    */
    document.body.classList.remove('dark')
  }
}, [theme])


/* =====================================================================
   5Ô∏è‚É£ COMO O BOT√ÉO MUDA O TEMA (PARTE MAIS IMPORTANTE)
===================================================================== */

/*
  ‚ùì Onde fica a l√≥gica do bot√£o?

  REGRA:
  - A l√≥gica FICA onde o estado existe
  - O bot√£o s√≥ DISPARA a a√ß√£o
*/


/*
  Fun√ß√£o de alternar tema

  L√≥gica mental:
  - Se est√° light ‚Üí vira dark
  - Se est√° dark ‚Üí vira light
*/

function toggleTheme() {
  setTheme(prev =>
    prev === 'light' ? 'dark' : 'light'
  )
}


/*
  Isso √© l√≥gica pura.
  Nada de CSS.
  Nada de Tailwind.
*/


/* =====================================================================
   6Ô∏è‚É£ BOT√ÉO (EXEMPLO NO NAVBAR)
===================================================================== */

/*
  üìç Navbar.tsx

  O Navbar N√ÉO sabe como o tema funciona.
  Ele s√≥ recebe:
  - theme (pra saber o estado atual)
  - setTheme ou toggleTheme (pra alterar)
*/

<button onClick={toggleTheme}>
  {theme === 'dark' ? 'üåô Dark' : '‚òÄÔ∏è Light'}
</button>


/*
  Quando o usu√°rio clica:
  1Ô∏è‚É£ O bot√£o chama toggleTheme
  2Ô∏è‚É£ toggleTheme muda o estado
  3Ô∏è‚É£ useEffect escuta a mudan√ßa
  4Ô∏è‚É£ body ganha ou perde a classe .dark
  5Ô∏è‚É£ CSS troca TODAS as cores
*/


/* =====================================================================
   7Ô∏è‚É£ COMO VOC√ä REFAZ ISSO EM QUALQUER PROJETO
===================================================================== */

/*
  CHECKLIST MENTAL:

  1Ô∏è‚É£ Criar CSS variables (light / dark)
  2Ô∏è‚É£ Criar estado global de tema
  3Ô∏è‚É£ Usar useEffect pra aplicar no body
  4Ô∏è‚É£ Criar fun√ß√£o de toggle
  5Ô∏è‚É£ Passar essa fun√ß√£o pro bot√£o

  Se voc√™ seguir isso, SEMPRE funciona.
*/


/* =====================================================================
   8Ô∏è‚É£ POR QUE ISSO √â PROFISSIONAL
===================================================================== */

/*
  ‚úî Reutiliz√°vel
  ‚úî Escal√°vel
  ‚úî F√°cil de manter
  ‚úî F√°cil de trocar paleta
  ‚úî N√£o acopla componentes
  ‚úî Funciona com qualquer UI
*/


/* =====================================================================
   FIM DAS ANOTA√á√ïES ‚Äî FEATURE FINALIZADA
===================================================================== */



-->






<!--
DATA:
27/01/2026
-->


<!--
==================== APRENDIZADO COMPLETO ====================

TEMA:
Carrossel de produtos com bot√µes inteligentes (‚Üê ‚Üí)
que aparecem e somem automaticamente conforme o scroll.

=============================================================
OBJETIVO GERAL
=============================================================

Criar uma lista horizontal de produtos (tipo carrossel),
sem usar bibliotecas externas,
onde o usu√°rio navega APENAS por bot√µes.

Regras do comportamento:
- O bot√£o da esquerda (voltar) S√ì aparece se N√ÉO estiver no primeiro produto
- O bot√£o da direita (avan√ßar) S√ì aparece se AINDA houver produtos √† frente
- Ao chegar no √∫ltimo produto, o bot√£o da direita SOME
- Ao voltar para o in√≠cio, o bot√£o da esquerda SOME
- O scroll manual (mouse/trackpad) √© desativado
- Apenas os bot√µes controlam a navega√ß√£o
- Os cards continuam clic√°veis normalmente

Isso gera uma UX limpa, profissional e igual a e-commerces reais.

=============================================================
IDEIA PRINCIPAL DO FUNCIONAMENTO
=============================================================

1) Os produtos ficam dentro de uma DIV horizontal (display: flex)
2) Essa DIV possui um scroll horizontal interno
3) Usamos useRef para acessar essa DIV no JavaScript
4) Movemos o scroll usando scrollBy()
5) Medimos a posi√ß√£o atual do scroll
6) Com base nessa posi√ß√£o, decidimos se os bot√µes aparecem ou n√£o

=============================================================
ESTRUTURA VISUAL DO CARROSSEL (RESUMO)
=============================================================

[ BOT√ÉO ‚Üê ]  [ PRODUTO ][ PRODUTO ][ PRODUTO ]  [ BOT√ÉO ‚Üí ]

Os bot√µes ficam fora da √°rea que rola.
A √°rea dos produtos se move sozinha.

=============================================================
PASSO 1 ‚Äî REFER√äNCIA DO ELEMENTO QUE VAI ROLAR
=============================================================

Usamos useRef para guardar a refer√™ncia da DIV que cont√©m os produtos.

C√≥digo:
const vendidosRef = useRef<HTMLDivElement | null>(null)

Isso permite:
- controlar o scroll
- ler a posi√ß√£o atual
- saber quando chegou no come√ßo ou no fim

=============================================================
PASSO 2 ‚Äî ESTADOS QUE CONTROLAM OS BOT√ïES
=============================================================

Criamos dois estados:
- canScrollLeft  ‚Üí controla o bot√£o de voltar
- canScrollRight ‚Üí controla o bot√£o de avan√ßar

C√≥digo:
const [canScrollLeft, setCanScrollLeft] = useState(false)
const [canScrollRight, setCanScrollRight] = useState(true)

Eles come√ßam assim porque:
- inicialmente estamos no come√ßo (n√£o pode voltar)
- ainda existem produtos √† direita

=============================================================
PASSO 3 ‚Äî ENTENDENDO OS VALORES DO SCROLL
=============================================================

Todo elemento com scroll possui 3 valores importantes:

- scrollLeft:
  Quanto j√° foi rolado para a direita

- clientWidth:
  Largura vis√≠vel da √°rea (o que o usu√°rio v√™)

- scrollWidth:
  Largura TOTAL do conte√∫do (todos os produtos juntos)

Com esses tr√™s valores conseguimos saber:
‚úîÔ∏è se ainda h√° produtos escondidos
‚úîÔ∏è se chegamos no come√ßo
‚úîÔ∏è se chegamos no fim

=============================================================
PASSO 4 ‚Äî FUN√á√ÉO QUE DECIDE SE OS BOT√ïES APARECEM
=============================================================

Essa √© a FUN√á√ÉO MAIS IMPORTANTE de toda a l√≥gica.

Ela analisa a posi√ß√£o atual do scroll
e atualiza os estados dos bot√µes.

C√≥digo:

function updateScrollButtons(ref: HTMLDivElement | null) {
  if (!ref) return

  const { scrollLeft, scrollWidth, clientWidth } = ref

  // Se j√° andou um pouco, pode voltar
  setCanScrollLeft(scrollLeft > 0)

  // Se ainda n√£o chegou no final, pode avan√ßar
  setCanScrollRight(
    scrollLeft + clientWidth < scrollWidth - 5
  )
}

O "-5" √© uma margem de seguran√ßa
para evitar erros de arredondamento.

=============================================================
PASSO 5 ‚Äî FUN√á√ÉO PARA AVAN√áAR OS PRODUTOS (‚Üí)
=============================================================

Quando o usu√°rio clica no bot√£o da direita,
movemos o scroll para frente.

C√≥digo:

function scrollNext(ref: HTMLDivElement | null) {
  if (!ref) return

  ref.scrollBy({
    left: 240,          // quantidade que avan√ßa
    behavior: 'smooth'  // anima√ß√£o suave
  })

  // Atualiza os bot√µes ap√≥s o movimento
  setTimeout(() => updateScrollButtons(ref), 300)
}

=============================================================
PASSO 6 ‚Äî FUN√á√ÉO PARA VOLTAR OS PRODUTOS (‚Üê)
=============================================================

Mesma l√≥gica, mas voltando.

C√≥digo:

function scrollPrev(ref: HTMLDivElement | null) {
  if (!ref) return

  ref.scrollBy({
    left: -240,         // valor negativo = volta
    behavior: 'smooth'
  })

  setTimeout(() => updateScrollButtons(ref), 300)
}

=============================================================
PASSO 7 ‚Äî ATUALIZAR AO SCROLL (SEGURAN√áA EXTRA)
=============================================================

Se por algum motivo o scroll mudar,
atualizamos os bot√µes.

C√≥digo:

function handleScroll() {
  updateScrollButtons(vendidosRef.current)
}

E usamos assim na DIV:
onScroll={handleScroll}

=============================================================
PASSO 8 ‚Äî DESATIVAR SCROLL MANUAL E MANTER CLIQUES
=============================================================

Desativamos o scroll manual do mouse,
for√ßando o uso dos bot√µes.

Mas os cards continuam clic√°veis.

C√≥digo:

DIV DO CARROSSEL:
className="pointer-events-none"

CARD:
className="pointer-events-auto"

=============================================================
PASSO 9 ‚Äî MOSTRAR OU ESCONDER OS BOT√ïES
=============================================================

Os bot√µes s√≥ aparecem se o estado permitir.

Exemplo:

{canScrollLeft && (
  <button onClick={() => scrollPrev(vendidosRef.current)}>
    ‚Üê
  </button>
)}

{canScrollRight && (
  <button onClick={() => scrollNext(vendidosRef.current)}>
    ‚Üí
  </button>
)}

=============================================================
RESULTADO FINAL
=============================================================

‚úîÔ∏è Carrossel funcional sem bibliotecas
‚úîÔ∏è Bot√µes aparecem e somem automaticamente
‚úîÔ∏è UX limpa e profissional
‚úîÔ∏è F√°cil de reaproveitar
‚úîÔ∏è C√≥digo organizado e compreens√≠vel
‚úîÔ∏è Ideal para e-commerce e portf√≥lio

=============================================================
COMO REPLICAR EM QUALQUER PROJETO
=============================================================

1) Criar uma lista horizontal (flex)
2) Usar useRef para acessar o elemento
3) Criar fun√ß√µes de scroll (scrollBy)
4) Medir scrollLeft, clientWidth e scrollWidth
5) Controlar bot√µes com useState
6) Mostrar ou esconder bot√µes dinamicamente

=============================================================
FIM DO APRENDIZADO
=============================================================
-->
